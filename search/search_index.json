{
    "docs": [
        {
            "location": "/",
            "text": "Atomist\n is a powerful automation platform that unifies events\nacross your software development and delivery tools into a cohesive\nmodel of code, people, and process.  Gain visibility and control over\nyour software delivery flow with automations that respond to commands\nand events.  The Atomist development automation platform provides the\ntools to make \nyou\n a more productive developer.\n\n\nUsing Atomist\n\u00b6\n\n\nYou can use Atomist\u2019s out-of-the-box automations or you can\nwrite your own.\n\n\nAtomist automations\n\u00b6\n\n\nInvite the Atomist bot into your Slack team and use the built-in\nautomations.  The bot sends you relevant, actionable messages that\nenable you to control your development flow from Slack, from project\ncreation to deployment to monitoring.\n\n\nCustom automations\n\u00b6\n\n\nYou can customize Atomist\u2019s built-in automations or write wholly new\nones.\n\n\nAtomist provides an automation API with integrations for your\ndevelopment tools and runtime platforms, native Slack notifications\nand commands, and an open source client and command-line interface.\n\n\nCustom automations can be used to further streamline development:\n\n\n\n\nNotify team members about events such as pushes, pull requests,\n    build failures, crash looping Kubernetes pods and more.\n\n\nCreate custom bot commands for fun and profit. Search\n    StackOverflow from Slack or exchange banter with other teams -\n    it\u2019s up to you.\n\n\nAutomate your release process - rather than delegating it to your\n    build system - so you can release with a single button press in\n    Slack.\n\n\nMerge pull requests automatically as soon as the required checks\n    and reviews pass.\n\n\nAuto-close issues when a fix is deployed to production.\n\n\nRoll back automatically: identify a commit that caused a\n    regression in production, revert the commit, and release the \u201cnew\u201d\n    version\n\n\n\n\nConcepts\n\u00b6\n\n\nAtomist is all about making you more productive by helping you to\nautomate away all the things that slow you down.  The following\nconcepts describe the pieces Atomist provides to make it easy for you\nto create automations that reduce repetitive work and distractions.\n\n\nDevelopment automation platform\n\u00b6\n\n\nAtomist\u2019s development automation platform is powered by a service that\ningests and correlates events from your software development flow.  At\nthe heart of the service is a single coherent model: code, people, and\nprocesses.  You query that model using \nGraphQL\n when you write\nyour own automations.\n\n\nAutomation client\n\u00b6\n\n\nAutomations are written and run within an\nAtomist \nautomation client\n, which interacts with the Atomist\nplatform using primarily GraphQL.  Each client hosts automations that\ncan be invoked via the Atomist bot, Slack buttons, or when events\noccur.  A client can host any number of automations, and can be hosted\nwherever the author likes: locally during testing, inside a corporate\nfirewall, or on a public cloud or PaaS.\n\n\nCommands\n\u00b6\n\n\nCommands\n perform actions when invoked by users sending the\nAtomist bot messages, clicking buttons in Slack, or running the\nAtomist CLI.\n\n\nExamples of commands include the bot command \ncreate issue\n and the\n\u201cmerge pull request\u201d command that users invoke by pressing a button in\nSlack.\n\n\nEvents\n\u00b6\n\n\nEvents\n can be sourced from anywhere: commits, pushes, CI\nbuilds, deployments, stack traces in production logs, etc.  When an\nevent is ingested, Atomist relates it to other events to build up\ncontextual information: a push containing commits triggers a CI build,\ncreating an artifact that gets deployed.  Atomist is able to take\nautomated action on any and all of these events along the chain.\n\n\nHow does an automation know what event it should act on?  GraphQL\nsubscriptions are used to define the trigger criteria.  For example,\nyou can create a subscription to receive an event whenever a\nKubernetes deployment results in a pod crash looping, providing an\nautomation that automatically rolls that deployment back and notifies\nthe committers of the failure.\n\n\nIntegrations\n\u00b6\n\n\nAtomist receives events from and performs operations on many systems,\nincluding version control, CI systems, Slack, and more.\n\n\nAtomist uses the native integration technology for each platform or\ntool.  For example, to integrate with GitHub and Travis CI, Atomist\nuses webhooks; to integrate with Slack it uses their native real-time\nmessaging (RTM) API.  For each platform Atomist integrates with, it\nrequests the minimal set of permissions required.\n\n\nIf you use a system or tool Atomist does not natively support, you can\nimplement your own integrations.  You can use whatever tools and\nlibraries you want to communicate with your systems, and then register\nthese custom event types with Atomist so it can properly connect them\nwith other events.\n\n\n\n\nWhat next?\n\u00b6\n\n\n\n\n\n\nIf you\u2019re new to Atomist, visit the \nAtomist web site\n to\n    learn more about Atomist and how we can help you and your team\n    deliver better software faster.\n\n\n\n\n\n\nIf you want to get started using Atomist, go to\n    the \nUsing Atomist\n page to get Atomist installed in your\n    Slack team, authorized in GitHub, and connected to your continuous\n    integration system.\n\n\n\n\n\n\nIf you already are using Atomist and are interested in writing\n    your own automations, you can begin with\n    the \nDeveloper Quick Start\n or go straight to\n    the \nDeveloper Guide\n to learn how to create and run\n    your own automations.",
            "title": "Introduction"
        },
        {
            "location": "/#using-atomist",
            "text": "You can use Atomist\u2019s out-of-the-box automations or you can\nwrite your own.",
            "title": "Using Atomist"
        },
        {
            "location": "/#atomist-automations",
            "text": "Invite the Atomist bot into your Slack team and use the built-in\nautomations.  The bot sends you relevant, actionable messages that\nenable you to control your development flow from Slack, from project\ncreation to deployment to monitoring.",
            "title": "Atomist automations"
        },
        {
            "location": "/#custom-automations",
            "text": "You can customize Atomist\u2019s built-in automations or write wholly new\nones.  Atomist provides an automation API with integrations for your\ndevelopment tools and runtime platforms, native Slack notifications\nand commands, and an open source client and command-line interface.  Custom automations can be used to further streamline development:   Notify team members about events such as pushes, pull requests,\n    build failures, crash looping Kubernetes pods and more.  Create custom bot commands for fun and profit. Search\n    StackOverflow from Slack or exchange banter with other teams -\n    it\u2019s up to you.  Automate your release process - rather than delegating it to your\n    build system - so you can release with a single button press in\n    Slack.  Merge pull requests automatically as soon as the required checks\n    and reviews pass.  Auto-close issues when a fix is deployed to production.  Roll back automatically: identify a commit that caused a\n    regression in production, revert the commit, and release the \u201cnew\u201d\n    version",
            "title": "Custom automations"
        },
        {
            "location": "/#concepts",
            "text": "Atomist is all about making you more productive by helping you to\nautomate away all the things that slow you down.  The following\nconcepts describe the pieces Atomist provides to make it easy for you\nto create automations that reduce repetitive work and distractions.",
            "title": "Concepts"
        },
        {
            "location": "/#development-automation-platform",
            "text": "Atomist\u2019s development automation platform is powered by a service that\ningests and correlates events from your software development flow.  At\nthe heart of the service is a single coherent model: code, people, and\nprocesses.  You query that model using  GraphQL  when you write\nyour own automations.",
            "title": "Development automation platform"
        },
        {
            "location": "/#automation-client",
            "text": "Automations are written and run within an\nAtomist  automation client , which interacts with the Atomist\nplatform using primarily GraphQL.  Each client hosts automations that\ncan be invoked via the Atomist bot, Slack buttons, or when events\noccur.  A client can host any number of automations, and can be hosted\nwherever the author likes: locally during testing, inside a corporate\nfirewall, or on a public cloud or PaaS.",
            "title": "Automation client"
        },
        {
            "location": "/#commands",
            "text": "Commands  perform actions when invoked by users sending the\nAtomist bot messages, clicking buttons in Slack, or running the\nAtomist CLI.  Examples of commands include the bot command  create issue  and the\n\u201cmerge pull request\u201d command that users invoke by pressing a button in\nSlack.",
            "title": "Commands"
        },
        {
            "location": "/#events",
            "text": "Events  can be sourced from anywhere: commits, pushes, CI\nbuilds, deployments, stack traces in production logs, etc.  When an\nevent is ingested, Atomist relates it to other events to build up\ncontextual information: a push containing commits triggers a CI build,\ncreating an artifact that gets deployed.  Atomist is able to take\nautomated action on any and all of these events along the chain.  How does an automation know what event it should act on?  GraphQL\nsubscriptions are used to define the trigger criteria.  For example,\nyou can create a subscription to receive an event whenever a\nKubernetes deployment results in a pod crash looping, providing an\nautomation that automatically rolls that deployment back and notifies\nthe committers of the failure.",
            "title": "Events"
        },
        {
            "location": "/#integrations",
            "text": "Atomist receives events from and performs operations on many systems,\nincluding version control, CI systems, Slack, and more.  Atomist uses the native integration technology for each platform or\ntool.  For example, to integrate with GitHub and Travis CI, Atomist\nuses webhooks; to integrate with Slack it uses their native real-time\nmessaging (RTM) API.  For each platform Atomist integrates with, it\nrequests the minimal set of permissions required.  If you use a system or tool Atomist does not natively support, you can\nimplement your own integrations.  You can use whatever tools and\nlibraries you want to communicate with your systems, and then register\nthese custom event types with Atomist so it can properly connect them\nwith other events.",
            "title": "Integrations"
        },
        {
            "location": "/#what-next",
            "text": "If you\u2019re new to Atomist, visit the  Atomist web site  to\n    learn more about Atomist and how we can help you and your team\n    deliver better software faster.    If you want to get started using Atomist, go to\n    the  Using Atomist  page to get Atomist installed in your\n    Slack team, authorized in GitHub, and connected to your continuous\n    integration system.    If you already are using Atomist and are interested in writing\n    your own automations, you can begin with\n    the  Developer Quick Start  or go straight to\n    the  Developer Guide  to learn how to create and run\n    your own automations.",
            "title": "What next?"
        },
        {
            "location": "/user/",
            "text": "/**\n    * Function that tracks a click on an outbound link in Analytics.\n    * This function takes a valid URL string as an argument, and uses that URL string\n    * as the event label. Setting the transport method to 'beacon' lets the hit be sent\n    * using 'navigator.sendBeacon' in browser that support it.\n    */\n    var trackOutboundLink = function(url) {\n        ga('send', 'event', 'outbound', 'click', url, {\n            'transport': 'beacon',\n            'hitCallback': function(){document.location = url;}\n        });\n    }\n\n\n\n\nThis is a step by step guide to setting up Atomist\u2019s built-in\nautomations to see and control your development flow\nfrom \nSlack\n.  To write your own automations, see the\nfull \ndeveloper guide\n.\n\n\nSlack\n\u00b6\n\n\nEnroll Slack bot\n\u00b6\n\n\nClick the \u201cAdd to Slack\u201d button below to invite the Atomist bot into\nyour Slack team.\n\n\n\n  \n\n    \n\n  \n\n\n\n\n\nSlack\u2019s default configuration allows all team members to add new Slack applications.\nHowever, your team\u2019s admins may decide to restrict the set of applications that can\ncan be added in your team.  The \npermissions management page\n has\nan \u201cApproved Apps\u201d setting to control this.\n\n\n\n\nIf your team requires approval for new apps and you\u2019re not a Slack\nadministrator, Slack helps you request approval from your Slack team\u2019s\nadministrators to install the Atomist application.\n\n\nCurrently the authorization process asks you to authorize two things:\n\n\n\n\nThe Atomist app adds a bot user named \u201c@atomist\u201d to your team.\n    Your team can \n\\invite\n the Atomist bot to channels to access the\n    full functionality of Atomist.  Bot users cannot create channels,\n    cannot join channels unless they are invited by a non-bot channel\n    member, and cannot see messages in channels where they are not a\n    member.\n\n\nAtomist requests a scope called \u201cModify public channels\u201d.  This\n    scope allows Atomist to help you setup channels.  For example,\n    when you \ncreate a project\n in a new GitHub\n    repository, Atomist can create a Slack channel to go with it.\n\n\n\n\n\n\nNote\n\n\nThe Atomist app creates new channels on behalf of the user who\nfirst authorizes Atomist.\n\n\n\n\nSlack team ID\n\u00b6\n\n\nSome operations, like \nconnecting your CI with Atomist\n, need you to pass\nin your Slack team ID. To get your Slack team ID, send \nteam\n to the Atomist\nbot.\n\n\nyou> /invite @atomist\nyou> @atomist team\natomist> The Slack id for team your-slack-team is T1L0V3JTP\n         16 of 24 users in this team have authorized themselves\n\n\n\n\nRemoving Atomist from Slack\n\u00b6\n\n\nYou can remove the bot from all your channels instantly\nby revoking access to the \u201cAtomist\u201d application.  We certainly hope it\ndoesn\u2019t come to this!\n\n\nThe \nApp Manage page\n has a \u201cRemove App\u201d button at\nthe bottom of the page.  Please \nlet us know\n if\nthere\u2019s anything we can do to clarify how the bot works within your\nSlack team.\n\n\nGitHub\n\u00b6\n\n\nAtomist helps you work with GitHub in two ways:\n\n\n\n\nBy enabling webhooks, your automations can react to\n    GitHub activities such as pushes, pull requests, or issues.\n\n\nAutomations can expose commands that access GitHub through\n    the v3 api, authorized by OAuth tokens.\n    Each user on your team must independently authorize Atomist \u2013\n    this means that your users remain within the boundaries\n    of the existing GitHub security model.  Atomist acts on \nbehalf\n of\n    your users, not \ninstead\n of them.\n\n\n\n\nGitHub user authorization\n\u00b6\n\n\nWhen the Atomist bot first arrives in a team, it will send a direct\nmessage to the authorizing user, requesting that they authorize\nAtomist to access GitHub on their behalf.\n\n\n\n\nThis same dialog will be shown to users anytime Atomist detects that\nan automation needs to access GitHub as that user.  Every user on the\nteam must individually opt in.  Atomist will display this option each\ntime an un-authorized user runs a command that requires a GitHub\nauthorization.  Users can ask for their current GitHub authorization\nstatus by running:\n\n\nyou> @atomist github\n\n\n\n\nAtomist will send a direct message to this user with their current\nGitHub authorization status.\n\n\nOrganization webhooks\n\u00b6\n\n\nGitHub organization members that have the \nowner role\n, are\nallowed to configure organization webhooks.  This is convenient\nbecause it only has to be configured once; however, you will require a\nuser who has the \nOwner\n role in your GitHub organization.\n\n\nyou> @atomist enroll org\n\n\n\n\nWhen you choose to enroll a GitHub organization, you will most likely\nbe prompted to authorize a new scope (Atomist only asks for new scopes\nwhen explicitly required).  The \nadmin:org_hook\n is required when\nenrolling a new GitHub organization.\n\n\n\n\nIf you are a member of more than one GitHub organization, Atomist will\nask you to choose which organization to enroll.\n\n\n\n\nFinally, you will be presented with a button to configure the organization webhook.\n\n\n\n\nRepository webhooks\n\u00b6\n\n\nIf your team does not use a GitHub organization account, you can\nchoose to configure webhooks on individual repositories owned by your\nuser account.\n\n\nyou> @atomist install webhook\n\n\n\n\nThe bot now asks for the \nowner\n of the repository.  This question is\nskipped if there is only one valid choice (your user account).  Next the bot\nasks you to select the repository to receive the new webhook.\n\n\n\n  \n\n\n\n\n\nLinking Slack & GitHub\n\u00b6\n\n\nNow that you have Slack and GitHub connected with Atomist, you should\n\u201clink\u201d GitHub repositories with Slack channels so you can see and\ncontrol your project\u2019s activity from Slack.  All you need to do is\ninvite the Atomist bot to a Slack channel and then send it \nrepo\n.\n\n\n/invite @atomist\n@atomist repo\n\n\n\n\nThe bot will open a thread and ask you what GitHub repository you want\nto link to the channel.  If you added an organization webhook, you can\nlink any repository in your GitHub organization.  If you added\nwebhooks to individual repositories, you will only be able to link\nthose repositories.\n\n\nContinuous integration\n\u00b6\n\n\nAtomist natively supports several continuous integration\n(CI) platforms, listening for CI events, correlating them with the\ncommits that triggered the build, and showing contextualized\nnotifications in a Slack channel linked to the repository.  To enable\nthis capability, just add the desired Atomist CI\nwebhook URL to your CI configuration.\n\n\n\n\nNote\n\n\nIn the examples below, replace \nTEAM_ID\n with your Slack team ID.\n\n\n\n\nCircleCI\n\u00b6\n\n\nTo send events from \nCircleCI\n to Atomist, add the following\nsnippet to your \n.circleci/config.yml\n configuration file.\n\n\nnotify\n:\n\n  \nwebhooks\n:\n\n    \n-\n \nurl\n:\n \nhttps://webhook.atomist.com/atomist/circle/teams/TEAM_ID\n\n\n\n\n\nJenkins\n\u00b6\n\n\nYou can send events from \nJenkins\n to Atomist using\nthe \nnotification plugin\n, configuring it to send its\npayload to\n\nhttps://webhook.atomist.com/atomist/jenkins/teams/TEAM_ID\n.\n\n\nIf you configure your build using a \nJenkinsfile\n, add\nthese functions to your \nJenkinsfile\n.  Don\u2019t forget to replace\n\nTEAM_ID\n with your Slack team ID.\n\n\nimport\n \ngroovy.json.JsonOutput\n\n\n\ndef\n \ngetSCMInformation\n()\n \n{\n\n    \ndef\n \ngitUrl\n \n=\n \nsh\n(\nreturnStdout:\n \ntrue\n,\n \nscript:\n \n'git config --get remote.origin.url'\n).\ntrim\n()\n\n    \ndef\n \ngitSha\n \n=\n \nsh\n(\nreturnStdout:\n \ntrue\n,\n \nscript:\n \n'git rev-parse HEAD'\n).\ntrim\n()\n\n    \ndef\n \ngitBranch\n \n=\n \nsh\n(\nreturnStdout:\n \ntrue\n,\n \nscript:\n \n'git name-rev --always --name-only HEAD'\n).\ntrim\n().\nreplace\n(\n'remotes/origin/'\n,\n \n''\n)\n\n    \nreturn\n \n[\n \nurl:\n \ngitUrl\n,\n \nbranch:\n \ngitBranch\n,\n \ncommit:\n \ngitSha\n \n]\n\n\n}\n\n\n\ndef\n \nnotifyAtomist\n(\nbuildStatus\n,\n \nbuildPhase\n=\n\"FINALIZED\"\n,\n\n                  \nendpoint\n=\n\"https://webhook.atomist.com/atomist/jenkins/teams/TEAM_ID\"\n)\n \n{\n\n\n    \ndef\n \npayload\n \n=\n \nJsonOutput\n.\ntoJson\n([\n\n        \nname:\n \nenv\n.\nJOB_NAME\n,\n\n        \nduration:\n \ncurrentBuild\n.\nduration\n,\n\n        \nbuild:\n \n[\n\n            \nnumber:\n \nenv\n.\nBUILD_NUMBER\n,\n\n            \nphase:\n \nbuildPhase\n,\n\n            \nstatus:\n \nbuildStatus\n,\n\n            \nfull_url:\n \nenv\n.\nBUILD_URL\n,\n\n            \nscm:\n \ngetSCMInformation\n()\n\n        \n]\n\n    \n])\n\n    \nsh\n \n\"curl --silent -XPOST -H 'Content-Type: application/json' -d '${payload}' ${endpoint}\"\n\n\n}\n\n\n\n\n\nThen call \nnotifyAtomist\n when the build starts (in the first\nstage) and ends (in the \npost\n block), sending the appropriate\nstatus and phase.\n\n\n\n\nStart: \nnotifyAtomist(\"STARTED\", \"STARTED\")\n\n\nSuccesful: \nnotifyAtomist(\"SUCCESS\")\n\n\nUnstable: \nnotifyAtomist(\"UNSTABLE\")\n\n\nFailure: \nnotifyAtomist(\"FAILURE\")\n\n\n\n\nTravis CI\n\u00b6\n\n\nTo send events from \nTravis CI\n to Atomist, add the\nfollowing snippet to your \n.travis.yml\n configuration file.\n\n\nnotifications\n:\n\n  \nwebhooks\n:\n\n    \nurls\n:\n\n      \n-\n \nhttps://webhook.atomist.com/atomist/travis/teams/TEAM_ID\n\n    \non_success\n:\n \nalways\n\n    \non_failure\n:\n \nalways\n\n    \non_start\n:\n \nalways\n\n    \non_cancel\n:\n \nalways\n\n    \non_error\n:\n \nalways",
            "title": "Using Atomist"
        },
        {
            "location": "/user/#slack",
            "text": "",
            "title": "Slack"
        },
        {
            "location": "/user/#enroll-slack-bot",
            "text": "Click the \u201cAdd to Slack\u201d button below to invite the Atomist bot into\nyour Slack team.  \n   \n     \n     Slack\u2019s default configuration allows all team members to add new Slack applications.\nHowever, your team\u2019s admins may decide to restrict the set of applications that can\ncan be added in your team.  The  permissions management page  has\nan \u201cApproved Apps\u201d setting to control this.   If your team requires approval for new apps and you\u2019re not a Slack\nadministrator, Slack helps you request approval from your Slack team\u2019s\nadministrators to install the Atomist application.  Currently the authorization process asks you to authorize two things:   The Atomist app adds a bot user named \u201c@atomist\u201d to your team.\n    Your team can  \\invite  the Atomist bot to channels to access the\n    full functionality of Atomist.  Bot users cannot create channels,\n    cannot join channels unless they are invited by a non-bot channel\n    member, and cannot see messages in channels where they are not a\n    member.  Atomist requests a scope called \u201cModify public channels\u201d.  This\n    scope allows Atomist to help you setup channels.  For example,\n    when you  create a project  in a new GitHub\n    repository, Atomist can create a Slack channel to go with it.    Note  The Atomist app creates new channels on behalf of the user who\nfirst authorizes Atomist.",
            "title": "Enroll Slack bot"
        },
        {
            "location": "/user/#slack-team-id",
            "text": "Some operations, like  connecting your CI with Atomist , need you to pass\nin your Slack team ID. To get your Slack team ID, send  team  to the Atomist\nbot.  you> /invite @atomist\nyou> @atomist team\natomist> The Slack id for team your-slack-team is T1L0V3JTP\n         16 of 24 users in this team have authorized themselves",
            "title": "Slack team ID"
        },
        {
            "location": "/user/#removing-atomist-from-slack",
            "text": "You can remove the bot from all your channels instantly\nby revoking access to the \u201cAtomist\u201d application.  We certainly hope it\ndoesn\u2019t come to this!  The  App Manage page  has a \u201cRemove App\u201d button at\nthe bottom of the page.  Please  let us know  if\nthere\u2019s anything we can do to clarify how the bot works within your\nSlack team.",
            "title": "Removing Atomist from Slack"
        },
        {
            "location": "/user/#github",
            "text": "Atomist helps you work with GitHub in two ways:   By enabling webhooks, your automations can react to\n    GitHub activities such as pushes, pull requests, or issues.  Automations can expose commands that access GitHub through\n    the v3 api, authorized by OAuth tokens.\n    Each user on your team must independently authorize Atomist \u2013\n    this means that your users remain within the boundaries\n    of the existing GitHub security model.  Atomist acts on  behalf  of\n    your users, not  instead  of them.",
            "title": "GitHub"
        },
        {
            "location": "/user/#github-user-authorization",
            "text": "When the Atomist bot first arrives in a team, it will send a direct\nmessage to the authorizing user, requesting that they authorize\nAtomist to access GitHub on their behalf.   This same dialog will be shown to users anytime Atomist detects that\nan automation needs to access GitHub as that user.  Every user on the\nteam must individually opt in.  Atomist will display this option each\ntime an un-authorized user runs a command that requires a GitHub\nauthorization.  Users can ask for their current GitHub authorization\nstatus by running:  you> @atomist github  Atomist will send a direct message to this user with their current\nGitHub authorization status.",
            "title": "GitHub user authorization"
        },
        {
            "location": "/user/#organization-webhooks",
            "text": "GitHub organization members that have the  owner role , are\nallowed to configure organization webhooks.  This is convenient\nbecause it only has to be configured once; however, you will require a\nuser who has the  Owner  role in your GitHub organization.  you> @atomist enroll org  When you choose to enroll a GitHub organization, you will most likely\nbe prompted to authorize a new scope (Atomist only asks for new scopes\nwhen explicitly required).  The  admin:org_hook  is required when\nenrolling a new GitHub organization.   If you are a member of more than one GitHub organization, Atomist will\nask you to choose which organization to enroll.   Finally, you will be presented with a button to configure the organization webhook.",
            "title": "Organization webhooks"
        },
        {
            "location": "/user/#repository-webhooks",
            "text": "If your team does not use a GitHub organization account, you can\nchoose to configure webhooks on individual repositories owned by your\nuser account.  you> @atomist install webhook  The bot now asks for the  owner  of the repository.  This question is\nskipped if there is only one valid choice (your user account).  Next the bot\nasks you to select the repository to receive the new webhook.",
            "title": "Repository webhooks"
        },
        {
            "location": "/user/#linking-slack-github",
            "text": "Now that you have Slack and GitHub connected with Atomist, you should\n\u201clink\u201d GitHub repositories with Slack channels so you can see and\ncontrol your project\u2019s activity from Slack.  All you need to do is\ninvite the Atomist bot to a Slack channel and then send it  repo .  /invite @atomist\n@atomist repo  The bot will open a thread and ask you what GitHub repository you want\nto link to the channel.  If you added an organization webhook, you can\nlink any repository in your GitHub organization.  If you added\nwebhooks to individual repositories, you will only be able to link\nthose repositories.",
            "title": "Linking Slack &amp; GitHub"
        },
        {
            "location": "/user/#continuous-integration",
            "text": "Atomist natively supports several continuous integration\n(CI) platforms, listening for CI events, correlating them with the\ncommits that triggered the build, and showing contextualized\nnotifications in a Slack channel linked to the repository.  To enable\nthis capability, just add the desired Atomist CI\nwebhook URL to your CI configuration.   Note  In the examples below, replace  TEAM_ID  with your Slack team ID.",
            "title": "Continuous integration"
        },
        {
            "location": "/user/#circleci",
            "text": "To send events from  CircleCI  to Atomist, add the following\nsnippet to your  .circleci/config.yml  configuration file.  notify : \n   webhooks : \n     -   url :   https://webhook.atomist.com/atomist/circle/teams/TEAM_ID",
            "title": "CircleCI"
        },
        {
            "location": "/user/#jenkins",
            "text": "You can send events from  Jenkins  to Atomist using\nthe  notification plugin , configuring it to send its\npayload to https://webhook.atomist.com/atomist/jenkins/teams/TEAM_ID .  If you configure your build using a  Jenkinsfile , add\nthese functions to your  Jenkinsfile .  Don\u2019t forget to replace TEAM_ID  with your Slack team ID.  import   groovy.json.JsonOutput  def   getSCMInformation ()   { \n     def   gitUrl   =   sh ( returnStdout:   true ,   script:   'git config --get remote.origin.url' ). trim () \n     def   gitSha   =   sh ( returnStdout:   true ,   script:   'git rev-parse HEAD' ). trim () \n     def   gitBranch   =   sh ( returnStdout:   true ,   script:   'git name-rev --always --name-only HEAD' ). trim (). replace ( 'remotes/origin/' ,   '' ) \n     return   [   url:   gitUrl ,   branch:   gitBranch ,   commit:   gitSha   ]  }  def   notifyAtomist ( buildStatus ,   buildPhase = \"FINALIZED\" , \n                   endpoint = \"https://webhook.atomist.com/atomist/jenkins/teams/TEAM_ID\" )   { \n\n     def   payload   =   JsonOutput . toJson ([ \n         name:   env . JOB_NAME , \n         duration:   currentBuild . duration , \n         build:   [ \n             number:   env . BUILD_NUMBER , \n             phase:   buildPhase , \n             status:   buildStatus , \n             full_url:   env . BUILD_URL , \n             scm:   getSCMInformation () \n         ] \n     ]) \n     sh   \"curl --silent -XPOST -H 'Content-Type: application/json' -d '${payload}' ${endpoint}\"  }   Then call  notifyAtomist  when the build starts (in the first\nstage) and ends (in the  post  block), sending the appropriate\nstatus and phase.   Start:  notifyAtomist(\"STARTED\", \"STARTED\")  Succesful:  notifyAtomist(\"SUCCESS\")  Unstable:  notifyAtomist(\"UNSTABLE\")  Failure:  notifyAtomist(\"FAILURE\")",
            "title": "Jenkins"
        },
        {
            "location": "/user/#travis-ci",
            "text": "To send events from  Travis CI  to Atomist, add the\nfollowing snippet to your  .travis.yml  configuration file.  notifications : \n   webhooks : \n     urls : \n       -   https://webhook.atomist.com/atomist/travis/teams/TEAM_ID \n     on_success :   always \n     on_failure :   always \n     on_start :   always \n     on_cancel :   always \n     on_error :   always",
            "title": "Travis CI"
        },
        {
            "location": "/quick-start/",
            "text": "Develop your first automations: a bot command and an event handler.\n\n\nSet up\n\u00b6\n\n\nFirst, be sure someone in your Slack team has completed\nthe \nsetup\n.  Then, install \nNode.js\n\n\nbrew install node\n\n\n\n\ninstall the Atomist CLI\n\n\nnpm install -g @atomist/automation-client\n\n\n\n\nand configure Atomist on your local system\n\n\natomist config\n\n\n\n\nBot commands\n\u00b6\n\n\nAtomist recognizes when someone invokes the bot command by sending the\nintent to the Atomist bot, then collects the required\nparameters, and invokes the code implementing your command.\n\n\nLet\u2019s try out a bot command that searches \nStack Overflow\n and replies with the results:\n\n\nFirst, clone the project containing the command handler code and all the\nnecessary project files.\n\n\ngit clone https://github.com/atomist-blogs/sof-command.git sof-command \\\n    && cd sof-command\n\n\n\n\n\n\nHint\n\n\nSetting up, building, and running an automation client follows\nthe same steps as any other standard TypeScript or JavaScript\nproject.\n\n\n\n\nNext install the project dependencies.\n\n\nnpm install\n\n\n\n\nThen build the project.\n\n\nnpm run build\n\n\n\n\nFinally, start the client process on your local system.\n\n\nnpm start\n\n\n\n\nThis last command will start up the \nclient\n, register the \u201csearch so\u201d\nbot command in your Slack team, and begin writing its logs to your\nterminal.\n\n\nGo ahead and test it by going to a channel in your Slack team that the\nAtomist bot has been invited to and send the bot the command\u2019s intent.\n\n\n@atomist search so q=\"spring 5\"\n\n\n\n\nIf you don\u2019t provide a value for the query parameter, the Atomist bot\nopens a thread and asks you to enter it.  You should get a response\nthat looks something like this:\n\n\n\n\nCongratulations, you just ran your own bot command!  For more\ndetailed information about writing your own commands, see the full documentation\nfor \ncommands\n.\n\n\nHandling events\n\u00b6\n\n\nEvent handlers react to GitHub pushes, updates to issues, pull\nrequests, or similar events.\n\n\nLet\u2019s add an event handler that notifies us in Slack when a commit is pushed\nto a repository - but only if the commit message contains\na string like \u201cCrushed #77!\u201d.\n\n\nThis code is in a different automation client, but you get it and run it the same way:\n\n\ngit clone git@github.com:atomist-blogs/event-handler.git event-handler \\\n    && cd event-handler \\\n    && npm install \\\n    && npm run build \\\n    && npm start\n\n\n\n\nNext, trigger this event handler by making a commit in\na \nrepository that is linked to a Slack channel\n. The\ncommit message should include the word \u201cCrushed\u201d followed by a\nreference to an issue in the form \n#N\n, replacing \nN\n with the number\nof the issue.\n\n\nPush that commit and the bot sends a message to the linked channel\nletting everyone know you crushed it!\n\n\nFor more detailed information about customizing event handling, see the full documentation\nfor \nevents\n.\n\n\nDive in\n\u00b6\n\n\n\n\nAtomist Automation Overview\n\n\nCommands\n\n\nEvents\n\n\nCrafting sophisticated \nSlack messages\n\n\nUsing \nGraphQL with the automation API",
            "title": "Developer Quick Start"
        },
        {
            "location": "/quick-start/#set-up",
            "text": "First, be sure someone in your Slack team has completed\nthe  setup .  Then, install  Node.js  brew install node  install the Atomist CLI  npm install -g @atomist/automation-client  and configure Atomist on your local system  atomist config",
            "title": "Set up"
        },
        {
            "location": "/quick-start/#bot-commands",
            "text": "Atomist recognizes when someone invokes the bot command by sending the\nintent to the Atomist bot, then collects the required\nparameters, and invokes the code implementing your command.  Let\u2019s try out a bot command that searches  Stack Overflow  and replies with the results:  First, clone the project containing the command handler code and all the\nnecessary project files.  git clone https://github.com/atomist-blogs/sof-command.git sof-command \\\n    && cd sof-command   Hint  Setting up, building, and running an automation client follows\nthe same steps as any other standard TypeScript or JavaScript\nproject.   Next install the project dependencies.  npm install  Then build the project.  npm run build  Finally, start the client process on your local system.  npm start  This last command will start up the  client , register the \u201csearch so\u201d\nbot command in your Slack team, and begin writing its logs to your\nterminal.  Go ahead and test it by going to a channel in your Slack team that the\nAtomist bot has been invited to and send the bot the command\u2019s intent.  @atomist search so q=\"spring 5\"  If you don\u2019t provide a value for the query parameter, the Atomist bot\nopens a thread and asks you to enter it.  You should get a response\nthat looks something like this:   Congratulations, you just ran your own bot command!  For more\ndetailed information about writing your own commands, see the full documentation\nfor  commands .",
            "title": "Bot commands"
        },
        {
            "location": "/quick-start/#handling-events",
            "text": "Event handlers react to GitHub pushes, updates to issues, pull\nrequests, or similar events.  Let\u2019s add an event handler that notifies us in Slack when a commit is pushed\nto a repository - but only if the commit message contains\na string like \u201cCrushed #77!\u201d.  This code is in a different automation client, but you get it and run it the same way:  git clone git@github.com:atomist-blogs/event-handler.git event-handler \\\n    && cd event-handler \\\n    && npm install \\\n    && npm run build \\\n    && npm start  Next, trigger this event handler by making a commit in\na  repository that is linked to a Slack channel . The\ncommit message should include the word \u201cCrushed\u201d followed by a\nreference to an issue in the form  #N , replacing  N  with the number\nof the issue.  Push that commit and the bot sends a message to the linked channel\nletting everyone know you crushed it!  For more detailed information about customizing event handling, see the full documentation\nfor  events .",
            "title": "Handling events"
        },
        {
            "location": "/quick-start/#dive-in",
            "text": "Atomist Automation Overview  Commands  Events  Crafting sophisticated  Slack messages  Using  GraphQL with the automation API",
            "title": "Dive in"
        },
        {
            "location": "/developer/",
            "text": "The Atomist development automation platform ingests events from your\nsoftware development systems:\n\n\n\n\nSource code repositories like \nGitHub.com\n\n    and \nGitHub Enterprise\n\n\nIssue tracking systems like \nGitHub\n and \nJira\n\n\nContinuous integration platforms\n    like \nTravis CI\n, \nCircleCI\n,\n    and \nJenkins\n\n\nApplication frameworks like \nSpring\n\n\nRuntime platforms like \nKubernetes\n and \nCloud Foundry\n\n\nCustom events from \nany\n other system you use\n\n\n\n\nand makes them available via an automation API.\n\n\nAs Atomist ingests events, typically via webhook JSON payloads, it\nautomatically correlates them to each other: commits to pushes to\nbuilds to deployments to running containers. This results in a data\nmodel that represents your development flow.  You can subscribe to\nevents and take action when they occur, with the data model providing\nthe necessary context so your automations can always do the right\nthing.\n\n\nThe development automation platform also provides a simple yet\npowerful interface for implementing custom chat bot commands.  Atomist\nprovides all the infrastructure needed to recognize commands, collect\nparameters, execute the code, and respond.  This lets you focus on\nwriting your bot command code, not boilerplate code and ceremony\naround running bots.\n\n\nThe Atomist automation API can be accessed via any compliant client.\nThe reference implementation of the client is open source, written\nin \nTypeScript\n, and available in\nthe \nautomation-client-ts\n GitHub repository and\nvia \nNPM\n.  The reference client provides local testing tools, a\nCLI, interactive querying of the data model, and interfaces for\nimplementing your own automations.\n\n\n\n\nGraphQL\n\u00b6\n\n\nThe Atomist automation API provides you access to the events and data\nfrom your development platforms using \nGraphQL\n, a\nwidely-used query language and runtime for APIs.\n\n\nYou can use GraphQL with the Atomist automation API for:\n\n\n\n\nQueries that fetch data directly\n\n\nSubscriptions to register the types of events you want to receive\n\n\nMutations to change data and make connections\n\n\n\n\nWebSockets\n\u00b6\n\n\nUnlike most API clients, an Atomist automation client must maintain\ncontact with the API server so that it can receive the events and\ncommands it\u2019s interested in as they occur.\n\n\nAutomation clients access the Atomist automation API via\na \nWebSocket\n connection.  WebSockets allow the API server to send\nevents and commands to the client without constant polling via HTTP\ncalls and without requiring clients to open up firewall holes. The\nWebSocket connection is initiated by the automation client when it\nstarts up, establishing a persistent two-way communication channel\nbetween the automation client and API that is resilient to\ninterruptions in connectivity.\n\n\n\n\nAutomations\n\u00b6\n\n\nThe rest of this section describes how to develop and run your own\nautomations.\n\n\nGet started\n\u00b6\n\n\n\n\nSetting up your system\n to develop and run\n    automations\n\n\nCommands\n\n\nEvents\n\n\n\n\nIn-depth topics\n\u00b6\n\n\n\n\nCrafting sophisticated \nSlack messages\n\n\nUsing \nGraphQL with the automation API\n\n\nCreating, building, and starting an \nautomation client\n\n\nRunning an automation client\n.\n\n\n\n\nOnce you\u2019ve finished this section, you\u2019ll have everything\nyou need to eliminate the pain points in your development and delivery\nprocesses.",
            "title": "Overview"
        },
        {
            "location": "/developer/#graphql",
            "text": "The Atomist automation API provides you access to the events and data\nfrom your development platforms using  GraphQL , a\nwidely-used query language and runtime for APIs.  You can use GraphQL with the Atomist automation API for:   Queries that fetch data directly  Subscriptions to register the types of events you want to receive  Mutations to change data and make connections",
            "title": "GraphQL"
        },
        {
            "location": "/developer/#websockets",
            "text": "Unlike most API clients, an Atomist automation client must maintain\ncontact with the API server so that it can receive the events and\ncommands it\u2019s interested in as they occur.  Automation clients access the Atomist automation API via\na  WebSocket  connection.  WebSockets allow the API server to send\nevents and commands to the client without constant polling via HTTP\ncalls and without requiring clients to open up firewall holes. The\nWebSocket connection is initiated by the automation client when it\nstarts up, establishing a persistent two-way communication channel\nbetween the automation client and API that is resilient to\ninterruptions in connectivity.",
            "title": "WebSockets"
        },
        {
            "location": "/developer/#automations",
            "text": "The rest of this section describes how to develop and run your own\nautomations.",
            "title": "Automations"
        },
        {
            "location": "/developer/#get-started",
            "text": "Setting up your system  to develop and run\n    automations  Commands  Events",
            "title": "Get started"
        },
        {
            "location": "/developer/#in-depth-topics",
            "text": "Crafting sophisticated  Slack messages  Using  GraphQL with the automation API  Creating, building, and starting an  automation client  Running an automation client .   Once you\u2019ve finished this section, you\u2019ll have everything\nyou need to eliminate the pain points in your development and delivery\nprocesses.",
            "title": "In-depth topics"
        },
        {
            "location": "/developer/prerequisites/",
            "text": "Before you begin developing and running your own automations, you need\nto have Atomist \nset up in your Slack team\n.\n\n\nNode.js\n\u00b6\n\n\nThe reference implementation of the Atomist automation API client is\nimplemented in \nTypeScript\n, a superset of \nJavaScript\n.  To develop and\nrun automations using the reference implementation of the automation\nclient, you must install Node.js.  The easiest way to install\nNode.js is to go to the \nNode.js web site\n and follow the\ninstallation instructions for your platform.  This makes the\n\nnode\n and \nnpm\n programs available on your system.\n\n\nAlternatively, macOS users with \nHomebrew\n\ncan install Node.js with the following command:\n\n\nbrew install node\n\n\n\n\nAtomist CLI\n\u00b6\n\n\nThe Atomist CLI performs several useful functions that are referred to\nthroughout this documentation.  Once you have Node.js installed,\ninstall the CLI with the following command:\n\n\nnpm install -g @atomist/automation-client\n\n\n\n\nGitHub token\n\u00b6\n\n\nThe Atomist automation API client uses\na \nGitHub personal access token\n to register with the Atomist\nAPI.  The Atomist API uses the token to confirm you are in a GitHub\norganization connected to the Slack team in which you are running your\nautomations.  The token needs \nread:org\n \nscope\n to see what GitHub\norganizations your GitHub user is in.  In addition, we recommend you\ninclude the \nrepo\n scope in the token you use since many automations\ninteract with GitHub repositories and require \nrepo\n scope to do their\nwork, e.g., comment on issues, create PRs, and create repositories.\n\n\n\n\nWarn\n\n\nIf you created your token before 2017-11-20, it may have been\ncreated with just the \nread:org\n scope.  If this is the case, the\ntoken can be used to register automations with the automation API\nbut automations that require access to GitHub repositories may\nfail since the token does not have \nrepo\n scope.  You can remedy\nthis issue by adding \nrepo\n scope to\nyour \nexisting Atomist API token(s)\n.\n\n\n\n\nThe easy way\n\u00b6\n\n\nThe easiest way to create the appropriate GitHub personal access token\nis to use the Atomist CLI\u2019s \nconfig\n command.\n\n\natomist config\n\n\n\n\nThe \natomist config\n command will prompt you for your Slack team ID\nand your GitHub credentials.  Your GitHub credentials are only used to\nauthenticate to GitHub so the personal access token can be created.\nAtomist does not retain your GitHub credentials and the generated\npersonal access token is only stored on your local system.\n\n\nThe hard way\n\u00b6\n\n\nIf you prefer to create the GitHub personal access token yourself, you\ncan do so on your GitHub.com \nnew personal access token\n\npage.  Give the token a descriptive name, like \u201cMy manually created\nAtomist token\u201d, and ensure \nread:org\n and \nrepo\n scopes are selected\nbefore clicking the \u201cGenerate token\u201d button.  Copy the generated\ntoken.  Finally, manually create your local Atomist configuration\nfile.\n\n\nOn UNIX-like systems:\n\n\n( umask 077 && mkdir -p \"$HOME/.atomist\" && touch \"$HOME/.atomist/client.config.json\" )\n\n\n\n\nOn MS Windows:\n\n\nmd %USERPROFILE%\\.atomist && type nul > %USERPROFILE%\\.atomist\\client.config.json\n\n\n\n\nOpen the \nclient.config.json\n file you just created in your favorite\ntext editor and add the following contents, replacing \nTEAM_ID\n with\nyour Slack team ID and \nGITHUB_TOKEN\n with the GitHub personal access\ntoken you just created.\n\n\n{\n\n  \n\"token\"\n:\n \n\"GITHUB_TOKEN\"\n,\n\n  \n\"teamIds\"\n:\n \n[\n\n    \n\"TEAM_ID\"\n\n  \n]\n\n\n}\n\n\n\n\n\nIf you are in multiple Slack teams and want to run your automations in\nall of them, simply add all of their team IDs to the \nteamIds\n array\nin the client configuration file.",
            "title": "Prerequisites"
        },
        {
            "location": "/developer/prerequisites/#nodejs",
            "text": "The reference implementation of the Atomist automation API client is\nimplemented in  TypeScript , a superset of  JavaScript .  To develop and\nrun automations using the reference implementation of the automation\nclient, you must install Node.js.  The easiest way to install\nNode.js is to go to the  Node.js web site  and follow the\ninstallation instructions for your platform.  This makes the node  and  npm  programs available on your system.  Alternatively, macOS users with  Homebrew \ncan install Node.js with the following command:  brew install node",
            "title": "Node.js"
        },
        {
            "location": "/developer/prerequisites/#atomist-cli",
            "text": "The Atomist CLI performs several useful functions that are referred to\nthroughout this documentation.  Once you have Node.js installed,\ninstall the CLI with the following command:  npm install -g @atomist/automation-client",
            "title": "Atomist CLI"
        },
        {
            "location": "/developer/prerequisites/#github-token",
            "text": "The Atomist automation API client uses\na  GitHub personal access token  to register with the Atomist\nAPI.  The Atomist API uses the token to confirm you are in a GitHub\norganization connected to the Slack team in which you are running your\nautomations.  The token needs  read:org   scope  to see what GitHub\norganizations your GitHub user is in.  In addition, we recommend you\ninclude the  repo  scope in the token you use since many automations\ninteract with GitHub repositories and require  repo  scope to do their\nwork, e.g., comment on issues, create PRs, and create repositories.   Warn  If you created your token before 2017-11-20, it may have been\ncreated with just the  read:org  scope.  If this is the case, the\ntoken can be used to register automations with the automation API\nbut automations that require access to GitHub repositories may\nfail since the token does not have  repo  scope.  You can remedy\nthis issue by adding  repo  scope to\nyour  existing Atomist API token(s) .",
            "title": "GitHub token"
        },
        {
            "location": "/developer/prerequisites/#the-easy-way",
            "text": "The easiest way to create the appropriate GitHub personal access token\nis to use the Atomist CLI\u2019s  config  command.  atomist config  The  atomist config  command will prompt you for your Slack team ID\nand your GitHub credentials.  Your GitHub credentials are only used to\nauthenticate to GitHub so the personal access token can be created.\nAtomist does not retain your GitHub credentials and the generated\npersonal access token is only stored on your local system.",
            "title": "The easy way"
        },
        {
            "location": "/developer/prerequisites/#the-hard-way",
            "text": "If you prefer to create the GitHub personal access token yourself, you\ncan do so on your GitHub.com  new personal access token \npage.  Give the token a descriptive name, like \u201cMy manually created\nAtomist token\u201d, and ensure  read:org  and  repo  scopes are selected\nbefore clicking the \u201cGenerate token\u201d button.  Copy the generated\ntoken.  Finally, manually create your local Atomist configuration\nfile.  On UNIX-like systems:  ( umask 077 && mkdir -p \"$HOME/.atomist\" && touch \"$HOME/.atomist/client.config.json\" )  On MS Windows:  md %USERPROFILE%\\.atomist && type nul > %USERPROFILE%\\.atomist\\client.config.json  Open the  client.config.json  file you just created in your favorite\ntext editor and add the following contents, replacing  TEAM_ID  with\nyour Slack team ID and  GITHUB_TOKEN  with the GitHub personal access\ntoken you just created.  { \n   \"token\" :   \"GITHUB_TOKEN\" , \n   \"teamIds\" :   [ \n     \"TEAM_ID\" \n   ]  }   If you are in multiple Slack teams and want to run your automations in\nall of them, simply add all of their team IDs to the  teamIds  array\nin the client configuration file.",
            "title": "The hard way"
        },
        {
            "location": "/developer/commands/",
            "text": "Trigger your automations from the web or Slack!  Commands respond to\nrequests \u2013 like \n@atomist do my thing\n or a button press.  You can\ncreate your own commands to make the Atomist bot do what you want.\n\n\nFor the fastest path to a command handler,\nfollow \nthis quick-start blog post\n.\n\n\nIf you already have an automation client,\nthis page will help you add a command handler to it.\n\n\nYou\u2019ll need\n\n\n\n\nAn \nautomation client\n of your own\n\n\nA task you want to automate, even if it\u2019s just saying \u201cHello, World!\u201d\n\n\nA phrase that people can say in Slack to trigger it, i.e., the commands \nintent\n\n\nA name for the command handler\n\n\n\n\nIn this guide you\u2019ll create MyCommandHandler, which responds to \u201cdo my thing\u201d.\n\n\nCommand handler\n\u00b6\n\n\nCommand handlers are classes with a \nhandle\n method and some\ndecorators that supply metadata.  Store them anywhere in the \nsrc\n\ndirectory; your automation client discovers them on startup\n(or \nspecify them yourself\n).\n\n\nYou can add a class to any file,\nor make a new TypeScript file anywhere in the \nsrc\n directory,\nlike \nsrc/commands/MyCommandHandler.ts\n.\n\n\nStart by copying the content of\n\nthe HelloWorld sample\n\ninto a new file to start with.\n\n\nA command handler class implements \nHandleCommand\n, with a \nhandle\n\nmethod, and is decorated with \n@CommandHandler\n.  It can also\ncontain \nparameter specifications\n to gather additional\ninformation.\n\n\nThe \n@CommandHandler(description: string, intent: string)\n decorator\non the class adds the top-level metadata that Atomist needs to run\nyour command handler.  The \nintent\n parameter is important: it\u2019s the\nphrase people type in Slack to trigger this handler. Your\n\ndescription\n will show up in help messages.\n\n\nImplement your automation in the \nhandle\n method.\n\n\nThe simplest command handler:\n\n\nimport\n \n{\n\n    \nCommandHandler\n,\n\n    \nHandleCommand\n,\n\n    \nHandlerContext\n,\n\n    \nHandlerResult\n,\n\n    \nSuccess\n,\n\n\n}\n \nfrom\n \n\"@atomist/automation-client\"\n;\n\n\n\n@CommandHandler\n(\n\"My sample command handler\"\n,\n \n\"do my thing\"\n)\n\n\nexport\n \nclass\n \nMyCommandHandler\n \nimplements\n \nHandleCommand\n \n{\n\n\n    \npublic\n \nhandle\n(\ncontext\n: \nHandlerContext\n)\n:\n \nPromise\n<\nHandlerResult\n>\n \n{\n\n        \nreturn\n \nPromise\n.\nresolve\n(\nSuccess\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nHandler arguments\n\u00b6\n\n\nThe \nhandle\n method receives a \nHandlerContext\n. It\ncontains the following useful members:\n\n\n\n\nmessageClient: MessageClient\n lets you send Slack messages from\n    the Atomist bot.  You can send messages to\n    particular \nusers\n,\n    particular \nchannels\n, or\n    to \nwhoever typed the command\n.\n\n\ngraphClient: GraphClient\n lets you run queries against the\n    Atomist \nGraphQL API\n, where you can discover things\n    like which builds failed on which commits, who made those commits,\n    and what their Slack username is.\n\n\n\n\nWhen you need more information, define \nparameters\n\nin your command handler.\n\n\nHandler return\n\u00b6\n\n\nA \nHandlerResult\n is an object containing a return code (0 for\nsuccess, anything else for error).  You can add other properties to\nthe object for debugging; they\u2019ll show up in your automation client\u2019s\nlog.  Return this \nHandlerResult\n after doing whatever it is you\u2019d\nlike your automation to accomplish.\n\n\nThe do-nothing \nhandle\n method creates a Promise from a successful\n\nHandlerResult\n:\n\n\nreturn\n \nPromise\n.\nresolve\n({\n \ncode\n: \n0\n \n})\n\n\n\n\n\nThere\u2019s a \nSuccess\n object in \n@atomist/automation-client/HandlerResult\n\nthat you can substitute for \n{ code: 0 }\n to be extra expressive, or a\n\nsuccess\n function for when you need \n() => { code: 0 }\n like when\ntranslating a Promise of something else into a \nHandlerResult\n: \npromise.then(success)\n.\n\n\nThe \nhandle\n method returns a Promise because usually you\u2019ll want to do something\nfun asynchronously, like respond in Slack.\nThe \nmessageClient.respond\n method returns a Promise,\nso you can return success after the message is sent:\n\n\nreturn\n \ncontext\n.\nmessageClient\n.\nrespond\n(\n\"That sounds like a great idea!\"\n)\n\n    \n.\nthen\n(\nsuccess\n)\n\n\n\n\n\n\n\n\nParameters\n\u00b6\n\n\nYou don\u2019t want your command handler to do the \nsame\n thing every\ntime. Gather more information from parameters!  By annotating your\ncommand handler fields with \n@Parameter\n, \n@MappedParameter\n, or\n\n@Secret\n, you are instructing Atomist automation API to collect and\nprovide values for those parameters when your command is invoked.\n\n\nYou can get this information from the user or button definition\n(\n@Parameter\n) or from Atomist\u2019s understanding of where the command\nwas invoked (\n@MappedParameter\n).\n\n\nInput Parameters\n\u00b6\n\n\nThese may be simple values that need to be supplied to run your\ncommand handler. For example, the issue number to close or the build\nnumber to restart. When a user invokes your command in Slack, the\nAtomist bot will prompt her in a thread to supply value for each\nrequired parameter. The user will get to review the provided parameter\nvalues, change them if desired, and click or type Submit.\n\n\n\n\nTip\n\n\nYou can supply parameters in one line with \nname=value\n pairs like: \n@atomist do my thing buildId=42\n.\n\n\n\n\n\n\nNote\n\n\nIf there are no required parameters, your command will be invoked right away.\n\n\n\n\nIn Slack buttons, the automation creating\nthe \nbutton\n can supply as many\nparameters as it knows. Whoever clicks the button will be prompted for\nany other required parameters.\n\n\nWhen you decorate a field with \n@Parameter\n,\nyou can pass the decorator an object describing the parameter.\nHere are some examples:\n\n\nA \nbuildId\n is required, and it is a \nstring\n of digits:\n\n\n@Parameter\n({\n \npattern\n:\n \n/^[0-9]+$/\n \n})\n\n\npublic\n \nbuildId\n: \nstring\n;\n\n\n\n\n\nAn animal can be specified, or it\u2019ll default to armadillo:\n\n\n@Parameter\n({})\n\n\npublic\n \nanimal\n: \nstring\n \n=\n \n\"armadillo\"\n;\n\n\n\n\n\nYou can define:\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\npattern\n\n\nIf you want to validate values, pass a \nRegExp\n. It must start with \n^\n and end with \n$\n so that it covers the whole value. Default: \n/^[\\S\\s]*$/\n for \u201canything\u201d\n\n\n\n\n\n\nrequired\n\n\nset this to \nfalse\n if the parameter is optional. If you supply a default value for the field, we\u2019ll automatically set required to \nfalse\n!\n\n\n\n\n\n\ndescription\n\n\nthe Slack or Atomist dashboard user will see this when they\u2019re prompted for the parameter.\n\n\n\n\n\n\ndisplayName\n\n\ndefaults to the name of the field you\u2019re decorating\n\n\n\n\n\n\nvalidInput\n\n\nif you supplied a pattern, you may also want to describe in words what input is valid.\n\n\n\n\n\n\ndisplayable\n\n\nIf \nfalse\n, hide this parameter from the user before when prompting them to submit. For instance, sometimes buttons include cryptic internal identifiers.\n\n\n\n\n\n\nmaxLength\n\n\nif you want to limit the length of a parameter, supply a number here.\n\n\n\n\n\n\nminLength\n\n\nif you want at least so many characters, supply a number here.\n\n\n\n\n\n\ntype\n\n\nstring\n or \nboolean\n or \nnumber\n, although we\u2019ll figure that out from the type of the field if we can.\n\n\n\n\n\n\n\n\nMapped Parameters\n\u00b6\n\n\nThere are a few things Atomist can infer from who invoked this command, or what channel they invoked it in.\nYou can request this information by decorating fields with \n@MappedParameter\n.\nSupply one argument to that decorator to tell it which of the MappedParameters you want.\n\n\n@MappedParameter\n(\nMappedParameters\n.\nSlackUserName\n)\n\n\npublic\n \nslackUserName\n: \nstring\n;\n\n\n\n\n\nIn Slack, if the value is ambiguous based on your team and channel, Atomist asks the user.\n\n\nIn Slack buttons, the automation that defines the button can provide values for these.\n\n\nThe available Mapped Parameters are:\n\n\n\n\n\n\n\n\nConstant\n\n\nWhat you get\n\n\n\n\n\n\n\n\n\n\nMappedParameters.SlackUserName\n\n\nWho invoked this command? This is the username, not the display name of the user. For instance: jessitron\n\n\n\n\n\n\nMappedParameters.SlackUser\n\n\nThe ID of the Slack user who invoked the command. For instance: U6L3BGG01;\n\n\n\n\n\n\nMappedParameters.SlackChannelName\n\n\nThe name of the channel where the command was invoked.\n\n\n\n\n\n\nMappedParameters.SlackChannel\n\n\nThe ID of the channel where the command was invoked. For instance: C3NGYQF6Y\n\n\n\n\n\n\nMappedParameters.SlackTeam\n\n\nThe ID of your Slack team. For instance: T6MFSPUDL\n\n\n\n\n\n\nMappedParameters.GitHubRepository\n\n\nIf the command was invoked in a \nchannel linked to exactly one repository\n, this is the name of it. Otherwise, prompt for one of the repository names in your team.\n\n\n\n\n\n\nMappedParameters.GitHubOwner\n\n\nIf your team has one \nlinked organization\n, this is it. If the command was invoked in a \nchannel linked to exactly one repository\n, this is the owner of that repository. Otherwise, prompt for one of the organizations linked to your team.\n\n\n\n\n\n\nMappedParameters.GitHubUrl\n\n\nThis is \nhttps://github.com\n unless you\u2019re on GitHub Enterprise.\n\n\n\n\n\n\nMappedParameters.GitHubApiUrl\n\n\nThis is \nhttps://api.github.com\n unless you\u2019re on GitHub Enterprise.\n\n\n\n\n\n\nMappedParameters.GitHubDefaultRepositoryVisibility\n\n\nour best guess for whether you prefer to create new repositories as \u201cpublic\u201d or \u201cprivate\u201d.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nMapped Parameters are available in Command Handlers but \nnot\n Event Handlers.\n\n\n\n\nExamples\n\u00b6\n\n\nHere are some examples of simple \ncommands\n.\n\n\nSend an HTTP request\n\u00b6\n\n\nCall endpoints on the internet or in your internal network, anywhere accessible where your own automation client is running.\n\n\nCheck out a\n\nvery simple HTTP example\n,\n or a more complicated one that\n \nSearches Stack Overflow\n.\n\n\nRespond\n\u00b6\n\n\nThis \nrespond\n message posts to Slack in the same\nchannel where the command was invoked.\n\n\nreturn\n \ncontext\n.\nmessageClient\n.\nrespond\n(\n\"I hear you.\"\n)\n\n           \n.\nthen\n(\nsuccess\n);\n\n\n\n\n\nSend a message to a Slack channel\n\u00b6\n\n\nSend a message to the channel you specify.\n\nHere\u2019s a simple handler\n.\n\n\nI use to send messages from automations under development to a particular Slack channel\nthat serves as an informal audit log.\n\n\nSend a direct message\n\u00b6\n\n\nPerhaps you\u2019d like to DM yourself whenever someone runs your automation.\nThe \naddressUsers\n method on the messageClient has a second argument: a Slack username or an array of Slack usernames.\n\n\nreturn\n \ncontext\n.\nmessageClient\n.\naddressUsers\n(\n\"ping\"\n,\n\"jessitron\"\n)\n\n           \n.\nthen\n(\nsuccess\n)\n\n\n\n\n\nSend a formatted message\n\u00b6\n\n\nAll of the messageClient methods (\nrespond\n, \naddressChannels\n,\n\naddressUsers\n) accept either a string or Slack message object.  Learn\nabout formatting options\non \nSlack\u2019s message builder page\n.\n\n\nFind full information about all the options\nunder \nSlack Messages\n, including how to add buttons.\n\n\n\n\n\nMake a code change\n\u00b6\n\n\nAtomist lets developers automate their work, and that includes\nchanging code.  The \n@atomist/automation-client\n module that you can\nfind in your automation client has tools for creating and editing\nprojects.\n\n\nFor instance, you might want to:\n\n\nAdd a file to a repository\n\u00b6\n\n\nThis example\n adds a \nCONTRIBUTING.md\n file to one\nrepository, with organization-standard content.\n\n\nLearn more in \neditors\n.\n\n\nChange the content of a file in all repositories\n\u00b6\n\n\nWhy stop at just one repository? This is automation! You can change them all!\n\n\nA command can \nupdate the copyright year in all the READMEs in all your repositories\n.\n\n\nWith this handler running\nin your automation client, you can initiate PRs on all out-of-date repositories with a single invocation of\n \n@atomist update README copyright year\n in Slack.\n\n\nLearn more in \neditors\n.\n\n\nInspect code across repositories\n\u00b6\n\n\nChecks which repositories are up to current coding standards.\n\n\nThis example\n\nchecks which repositories have a current copyright notice in the README. It then reports on every repository: Does it have a copyright notice? If so, is it up-to-date?\n\n\nMake a new repository\n\u00b6\n\n\nWhen you want to make a new service or library, it\u2019s common to start by copying an old one. With Atomist,\nyou can automate the copy, and modify the starting point to be your new service.\n\n\nCheck out this\n\nexample\n\nthat copies a sample automation client into your own repository.\n\n\nOnce the repository is created, you can do things like add collaborators, teams, or labels to bring the\nGitHub repository to your standards. For examples, the Atomist\n\nSpring generator\n\nadds a collaborator\n(and accepts the invitation) as part of project creation.\n\n\nCommands in the wild\n\u00b6\n\n\nThere\u2019s a \nrepository full of sample automations\n with\nexample commands, including editors and generators.\n\n\nThe built-in GitHub and build notifications, along with commands like\n\ncreate issue\n, live in \nlifecycle-automation\n.\n\n\nOne handy command for automation developers runs tslint in a Docker\ncontainer for every push to a TypeScript repository.  You\u2019ll find it\nin the \ndocker samples\n.\n\n\nTell us\n about yours!\n\n\nTesting\n\u00b6\n\n\nYou can test command handlers the same way you test any TypeScript\nclass.\n\nA client doc\n describes the Atomist team\u2019s testing style for commands, but there are many ways to test.\nIf you already have a favorite TypeScript or JavaScript testing style and framework, use that.\n\n\nYou can also test command handlers by hand: run the client locally and\nthen address Atomist in a Slack DM or a channel.\n\n\n\n\n\nTroubleshooting\n\u00b6\n\n\nAnything you print with console.log() in your command handler will show up in the logs of your automation-client.\nIf you\u2019re running locally, these logs go to stdout.\n\n\nMy intent was not recognized\n\u00b6\n\n\nWhen you tell Atomist to do the thing, and it responds with\n\n\nHmm, I don't understand 'do my thing'. How about: ...\n\n\nIt\u2019ll guess at nearby commands. This means it didn\u2019t find your intent.\n\n\nTo see everything available, try \n@atomist show skills\n.\nThis lists commands registered by automation client.\n Is your automation client listed?\nIf not, perhaps it is not running.\n\n\nIf you can\u2019t tell, consider changing the name of your automation client\n(in package.json) to something you\u2019ll recognize.\n\n\nIf your automation client is listed but your automation is not,\nperhaps it is not included in \natomist.config.ts\n.\n\n\nCommand was invoked unsuccessfully\n\u00b6\n\n\nWhen your handler returns a failure status, you\u2019ll see a message in Slack:\n\n\nUnable to run command\nUnsuccessfully invoked command-handler MyCommandHandler of my-automation@0.1.0\n\n\n\n\nCheck the logs of your automation client to figure out what went wrong.\n\n\n\n\n\nSomething went wrong\n\u00b6\n\n\nIf the bot tells you \u201cOops, something went wrong\u201d\u2026  that\u2019s our\nbad.  Please contact us through any of our \nsupport channels\n.\nWe want to help!",
            "title": "Commands"
        },
        {
            "location": "/developer/commands/#command-handler",
            "text": "Command handlers are classes with a  handle  method and some\ndecorators that supply metadata.  Store them anywhere in the  src \ndirectory; your automation client discovers them on startup\n(or  specify them yourself ).  You can add a class to any file,\nor make a new TypeScript file anywhere in the  src  directory,\nlike  src/commands/MyCommandHandler.ts .  Start by copying the content of the HelloWorld sample \ninto a new file to start with.  A command handler class implements  HandleCommand , with a  handle \nmethod, and is decorated with  @CommandHandler .  It can also\ncontain  parameter specifications  to gather additional\ninformation.  The  @CommandHandler(description: string, intent: string)  decorator\non the class adds the top-level metadata that Atomist needs to run\nyour command handler.  The  intent  parameter is important: it\u2019s the\nphrase people type in Slack to trigger this handler. Your description  will show up in help messages.  Implement your automation in the  handle  method.  The simplest command handler:  import   { \n     CommandHandler , \n     HandleCommand , \n     HandlerContext , \n     HandlerResult , \n     Success ,  }   from   \"@atomist/automation-client\" ;  @CommandHandler ( \"My sample command handler\" ,   \"do my thing\" )  export   class   MyCommandHandler   implements   HandleCommand   { \n\n     public   handle ( context :  HandlerContext ) :   Promise < HandlerResult >   { \n         return   Promise . resolve ( Success ); \n     }  }",
            "title": "Command handler"
        },
        {
            "location": "/developer/commands/#handler-arguments",
            "text": "The  handle  method receives a  HandlerContext . It\ncontains the following useful members:   messageClient: MessageClient  lets you send Slack messages from\n    the Atomist bot.  You can send messages to\n    particular  users ,\n    particular  channels , or\n    to  whoever typed the command .  graphClient: GraphClient  lets you run queries against the\n    Atomist  GraphQL API , where you can discover things\n    like which builds failed on which commits, who made those commits,\n    and what their Slack username is.   When you need more information, define  parameters \nin your command handler.",
            "title": "Handler arguments"
        },
        {
            "location": "/developer/commands/#handler-return",
            "text": "A  HandlerResult  is an object containing a return code (0 for\nsuccess, anything else for error).  You can add other properties to\nthe object for debugging; they\u2019ll show up in your automation client\u2019s\nlog.  Return this  HandlerResult  after doing whatever it is you\u2019d\nlike your automation to accomplish.  The do-nothing  handle  method creates a Promise from a successful HandlerResult :  return   Promise . resolve ({   code :  0   })   There\u2019s a  Success  object in  @atomist/automation-client/HandlerResult \nthat you can substitute for  { code: 0 }  to be extra expressive, or a success  function for when you need  () => { code: 0 }  like when\ntranslating a Promise of something else into a  HandlerResult :  promise.then(success) .  The  handle  method returns a Promise because usually you\u2019ll want to do something\nfun asynchronously, like respond in Slack.\nThe  messageClient.respond  method returns a Promise,\nso you can return success after the message is sent:  return   context . messageClient . respond ( \"That sounds like a great idea!\" ) \n     . then ( success )",
            "title": "Handler return"
        },
        {
            "location": "/developer/commands/#parameters",
            "text": "You don\u2019t want your command handler to do the  same  thing every\ntime. Gather more information from parameters!  By annotating your\ncommand handler fields with  @Parameter ,  @MappedParameter , or @Secret , you are instructing Atomist automation API to collect and\nprovide values for those parameters when your command is invoked.  You can get this information from the user or button definition\n( @Parameter ) or from Atomist\u2019s understanding of where the command\nwas invoked ( @MappedParameter ).",
            "title": "Parameters"
        },
        {
            "location": "/developer/commands/#input-parameters",
            "text": "These may be simple values that need to be supplied to run your\ncommand handler. For example, the issue number to close or the build\nnumber to restart. When a user invokes your command in Slack, the\nAtomist bot will prompt her in a thread to supply value for each\nrequired parameter. The user will get to review the provided parameter\nvalues, change them if desired, and click or type Submit.   Tip  You can supply parameters in one line with  name=value  pairs like:  @atomist do my thing buildId=42 .    Note  If there are no required parameters, your command will be invoked right away.   In Slack buttons, the automation creating\nthe  button  can supply as many\nparameters as it knows. Whoever clicks the button will be prompted for\nany other required parameters.  When you decorate a field with  @Parameter ,\nyou can pass the decorator an object describing the parameter.\nHere are some examples:  A  buildId  is required, and it is a  string  of digits:  @Parameter ({   pattern :   /^[0-9]+$/   })  public   buildId :  string ;   An animal can be specified, or it\u2019ll default to armadillo:  @Parameter ({})  public   animal :  string   =   \"armadillo\" ;   You can define:     Field  Meaning      pattern  If you want to validate values, pass a  RegExp . It must start with  ^  and end with  $  so that it covers the whole value. Default:  /^[\\S\\s]*$/  for \u201canything\u201d    required  set this to  false  if the parameter is optional. If you supply a default value for the field, we\u2019ll automatically set required to  false !    description  the Slack or Atomist dashboard user will see this when they\u2019re prompted for the parameter.    displayName  defaults to the name of the field you\u2019re decorating    validInput  if you supplied a pattern, you may also want to describe in words what input is valid.    displayable  If  false , hide this parameter from the user before when prompting them to submit. For instance, sometimes buttons include cryptic internal identifiers.    maxLength  if you want to limit the length of a parameter, supply a number here.    minLength  if you want at least so many characters, supply a number here.    type  string  or  boolean  or  number , although we\u2019ll figure that out from the type of the field if we can.",
            "title": "Input Parameters"
        },
        {
            "location": "/developer/commands/#mapped-parameters",
            "text": "There are a few things Atomist can infer from who invoked this command, or what channel they invoked it in.\nYou can request this information by decorating fields with  @MappedParameter .\nSupply one argument to that decorator to tell it which of the MappedParameters you want.  @MappedParameter ( MappedParameters . SlackUserName )  public   slackUserName :  string ;   In Slack, if the value is ambiguous based on your team and channel, Atomist asks the user.  In Slack buttons, the automation that defines the button can provide values for these.  The available Mapped Parameters are:     Constant  What you get      MappedParameters.SlackUserName  Who invoked this command? This is the username, not the display name of the user. For instance: jessitron    MappedParameters.SlackUser  The ID of the Slack user who invoked the command. For instance: U6L3BGG01;    MappedParameters.SlackChannelName  The name of the channel where the command was invoked.    MappedParameters.SlackChannel  The ID of the channel where the command was invoked. For instance: C3NGYQF6Y    MappedParameters.SlackTeam  The ID of your Slack team. For instance: T6MFSPUDL    MappedParameters.GitHubRepository  If the command was invoked in a  channel linked to exactly one repository , this is the name of it. Otherwise, prompt for one of the repository names in your team.    MappedParameters.GitHubOwner  If your team has one  linked organization , this is it. If the command was invoked in a  channel linked to exactly one repository , this is the owner of that repository. Otherwise, prompt for one of the organizations linked to your team.    MappedParameters.GitHubUrl  This is  https://github.com  unless you\u2019re on GitHub Enterprise.    MappedParameters.GitHubApiUrl  This is  https://api.github.com  unless you\u2019re on GitHub Enterprise.    MappedParameters.GitHubDefaultRepositoryVisibility  our best guess for whether you prefer to create new repositories as \u201cpublic\u201d or \u201cprivate\u201d.      Note  Mapped Parameters are available in Command Handlers but  not  Event Handlers.",
            "title": "Mapped Parameters"
        },
        {
            "location": "/developer/commands/#examples",
            "text": "Here are some examples of simple  commands .",
            "title": "Examples"
        },
        {
            "location": "/developer/commands/#send-an-http-request",
            "text": "Call endpoints on the internet or in your internal network, anywhere accessible where your own automation client is running.  Check out a very simple HTTP example ,\n or a more complicated one that\n  Searches Stack Overflow .",
            "title": "Send an HTTP request"
        },
        {
            "location": "/developer/commands/#respond",
            "text": "This  respond  message posts to Slack in the same\nchannel where the command was invoked.  return   context . messageClient . respond ( \"I hear you.\" ) \n            . then ( success );",
            "title": "Respond"
        },
        {
            "location": "/developer/commands/#send-a-message-to-a-slack-channel",
            "text": "Send a message to the channel you specify. Here\u2019s a simple handler .  I use to send messages from automations under development to a particular Slack channel\nthat serves as an informal audit log.",
            "title": "Send a message to a Slack channel"
        },
        {
            "location": "/developer/commands/#send-a-direct-message",
            "text": "Perhaps you\u2019d like to DM yourself whenever someone runs your automation.\nThe  addressUsers  method on the messageClient has a second argument: a Slack username or an array of Slack usernames.  return   context . messageClient . addressUsers ( \"ping\" , \"jessitron\" ) \n            . then ( success )",
            "title": "Send a direct message"
        },
        {
            "location": "/developer/commands/#send-a-formatted-message",
            "text": "All of the messageClient methods ( respond ,  addressChannels , addressUsers ) accept either a string or Slack message object.  Learn\nabout formatting options\non  Slack\u2019s message builder page .  Find full information about all the options\nunder  Slack Messages , including how to add buttons.",
            "title": "Send a formatted message"
        },
        {
            "location": "/developer/commands/#make-a-code-change",
            "text": "Atomist lets developers automate their work, and that includes\nchanging code.  The  @atomist/automation-client  module that you can\nfind in your automation client has tools for creating and editing\nprojects.  For instance, you might want to:",
            "title": "Make a code change"
        },
        {
            "location": "/developer/commands/#add-a-file-to-a-repository",
            "text": "This example  adds a  CONTRIBUTING.md  file to one\nrepository, with organization-standard content.  Learn more in  editors .",
            "title": "Add a file to a repository"
        },
        {
            "location": "/developer/commands/#change-the-content-of-a-file-in-all-repositories",
            "text": "Why stop at just one repository? This is automation! You can change them all!  A command can  update the copyright year in all the READMEs in all your repositories .  With this handler running\nin your automation client, you can initiate PRs on all out-of-date repositories with a single invocation of\n  @atomist update README copyright year  in Slack.  Learn more in  editors .",
            "title": "Change the content of a file in all repositories"
        },
        {
            "location": "/developer/commands/#inspect-code-across-repositories",
            "text": "Checks which repositories are up to current coding standards.  This example \nchecks which repositories have a current copyright notice in the README. It then reports on every repository: Does it have a copyright notice? If so, is it up-to-date?",
            "title": "Inspect code across repositories"
        },
        {
            "location": "/developer/commands/#make-a-new-repository",
            "text": "When you want to make a new service or library, it\u2019s common to start by copying an old one. With Atomist,\nyou can automate the copy, and modify the starting point to be your new service.  Check out this example \nthat copies a sample automation client into your own repository.  Once the repository is created, you can do things like add collaborators, teams, or labels to bring the\nGitHub repository to your standards. For examples, the Atomist Spring generator \nadds a collaborator\n(and accepts the invitation) as part of project creation.",
            "title": "Make a new repository"
        },
        {
            "location": "/developer/commands/#commands-in-the-wild",
            "text": "There\u2019s a  repository full of sample automations  with\nexample commands, including editors and generators.  The built-in GitHub and build notifications, along with commands like create issue , live in  lifecycle-automation .  One handy command for automation developers runs tslint in a Docker\ncontainer for every push to a TypeScript repository.  You\u2019ll find it\nin the  docker samples .  Tell us  about yours!",
            "title": "Commands in the wild"
        },
        {
            "location": "/developer/commands/#testing",
            "text": "You can test command handlers the same way you test any TypeScript\nclass. A client doc  describes the Atomist team\u2019s testing style for commands, but there are many ways to test.\nIf you already have a favorite TypeScript or JavaScript testing style and framework, use that.  You can also test command handlers by hand: run the client locally and\nthen address Atomist in a Slack DM or a channel.",
            "title": "Testing"
        },
        {
            "location": "/developer/commands/#troubleshooting",
            "text": "Anything you print with console.log() in your command handler will show up in the logs of your automation-client.\nIf you\u2019re running locally, these logs go to stdout.",
            "title": "Troubleshooting"
        },
        {
            "location": "/developer/commands/#my-intent-was-not-recognized",
            "text": "When you tell Atomist to do the thing, and it responds with  Hmm, I don't understand 'do my thing'. How about: ...  It\u2019ll guess at nearby commands. This means it didn\u2019t find your intent.  To see everything available, try  @atomist show skills .\nThis lists commands registered by automation client.\n Is your automation client listed?\nIf not, perhaps it is not running.  If you can\u2019t tell, consider changing the name of your automation client\n(in package.json) to something you\u2019ll recognize.  If your automation client is listed but your automation is not,\nperhaps it is not included in  atomist.config.ts .",
            "title": "My intent was not recognized"
        },
        {
            "location": "/developer/commands/#command-was-invoked-unsuccessfully",
            "text": "When your handler returns a failure status, you\u2019ll see a message in Slack:  Unable to run command\nUnsuccessfully invoked command-handler MyCommandHandler of my-automation@0.1.0  Check the logs of your automation client to figure out what went wrong.",
            "title": "Command was invoked unsuccessfully"
        },
        {
            "location": "/developer/commands/#something-went-wrong",
            "text": "If the bot tells you \u201cOops, something went wrong\u201d\u2026  that\u2019s our\nbad.  Please contact us through any of our  support channels .\nWe want to help!",
            "title": "Something went wrong"
        },
        {
            "location": "/developer/events/",
            "text": "Event handlers are automations that trigger when events happen, such\nas pull requests, updated issues, failed builds and more.  You can\ncreate your own event handlers to make Atomist react however you want.\n\n\nTo create an event handler, you\nneed \nan automation client of your own\n and an event you want\nto react to.  The sample event handler below notifies you in Slack when\na new GitHub issue is created.\n\n\nWhen writing an event handler, you need to understand the events\ninvolved. You\ncan\n\nuse GraphiQL to query for events\n\ntheir properties, and their relationships.  For example, this query\nshows the issue number and title for all your issues.\n\n\n{\n  Issue {\n    number\n    title\n  }\n}\n\n\n\n\nEvents can have relationships when it makes sense, even between\ndifferent systems. Issues are related to their repo, and GitHub repos\nmay also be associated with Slack channels. You can get all the\ninformation about these relationships in one query.\n\n\n{\n  Issue {\n    number\n    title\n    repo {\n      owner\n      name\n      channels {\n        name\n      }\n    }\n  }\n}\n\n\n\n\nThis query actually returns more data than is needed. In this case you\nonly want the open issues. You can use a GraphQL argument to get\nexactly that, without making additional queries, and without having to\nfilter the results later in code.\n\n\n{\n  Issue(state: open) {\n    number\n    title\n    repo {\n      owner\n      name\n      channels {\n        name\n      }\n    }\n  }\n}\n\n\n\n\nThere are a lot of interesting events and convenient relationships\nbetween them.  Exploring your builds, releases, Slack channels,\ncomments and more using GraphQL may give you additional ideas for\nevent handlers to build.  For now, let\u2019s use this query to write our\nevent handler.\n\n\nEvent handler structure\n\u00b6\n\n\nHere is a complete event handler that listens for new issues and\nnotifies you.\n\n\nimport\n \n{\n \nEventHandler\n \n}\n \nfrom\n \n\"@atomist/automation-client/decorators\"\n;\n\n\nimport\n \n{\n \nEventFired\n,\n \nHandleEvent\n \n}\n \nfrom\n \n\"@atomist/automation-client/HandleEvent\"\n;\n\n\nimport\n \n{\n \nHandlerContext\n \n}\n \nfrom\n \n\"@atomist/automation-client/HandlerContext\"\n;\n\n\nimport\n \n{\n\n    \nfailure\n,\n\n    \nHandlerResult\n,\n\n    \nsuccess\n\n\n}\n \nfrom\n \n\"@atomist/automation-client/HandlerResult\"\n;\n\n\n\n@EventHandler\n(\n\"Notify channel on new issue\"\n,\n\n    \n`subscription IssueNotification\n\n\n{\n\n\n  Issue(state: open) {\n\n\n    number\n\n\n    title\n\n\n    repo {\n\n\n      owner\n\n\n      name\n\n\n      channels {\n\n\n        name\n\n\n      }\n\n\n    }\n\n\n  }\n\n\n}`\n)\n\n\nexport\n \nclass\n \nIssueNotification\n \nimplements\n \nHandleEvent\n<\nIssues\n>\n \n{\n\n    \npublic\n \nhandle\n(\ne\n: \nEventFired\n<\nIssues\n>\n,\n \nctx\n: \nHandlerContext\n)\n:\n \nPromise\n<\nHandlerResult\n>\n \n{\n\n        \nconst\n \nissue\n \n=\n \ne\n.\ndata\n.\nIssue\n[\n0\n];\n\n        \nreturn\n \nctx\n.\nmessageClient\n.\naddressChannels\n(\n\n            \n`New issue: #\n${\nissue\n.\nnumber\n}\n '\n${\nissue\n.\ntitle\n}\n' in \n${\nissue\n.\nrepo\n.\nowner\n}\n.\n${\nissue\n.\nrepo\n.\nname\n}\n`\n,\n\n            \nissue\n.\nrepo\n.\nchannels\n.\nmap\n(\nc\n \n=>\n \nc\n.\nname\n)\n\n        \n)\n\n            \n.\nthen\n(\nsuccess\n,\n \nfailure\n);\n\n    \n}\n\n\n}\n\n\n\nexport\n \ninterface\n \nIssues\n \n{\n\n    \nIssue\n:\n \n[{\n\n        \nnumber\n:\n \nnumber\n;\n\n        \ntitle\n: \nstring\n;\n\n        \nrepo\n:\n \n{\n\n            \nowner\n: \nstring\n;\n\n            \nname\n: \nstring\n;\n\n            \nchannels\n:\n \n[{\n\n                \nname\n: \nstring\n;\n\n            \n}]\n\n        \n}\n\n    \n}]\n\n\n}\n\n\n\n\n\nThe \n@EventHandler\n decorator allows you to provide a description and\na query to subscribe to. Notice the GraphQL that you built up in the\nprevious section.  You\ncan \ndefine the subscription GraphQL query\n inline\nor reference a file. It also implements \nHandleEvent\n which specifies\nthe handle method.  This is where your automation code goes. Every\nmatching event triggers the code here.  From here you have access to\nthe event itself with \nEventFired\n and\na \nHandlerContext\n for interacting with Slack or\nquerying more events.  While a command handler has \n@Parameters\n and\n\n@MappedParamters\n to specify the details on invocation, an event\nhandler does not.  Instead it acts on the data inside the event.\n\n\nThis example uses the \nHandlerContext\n to send a message about the new\nissue to any associated channels it has.  Most of the work is done\njust by the subscription query that provides the data the event\nhandler needs.  The \nIssues\n interface exists merely for the\nconvenience of having a typed \nEventFired\n, but there are ways to\n\ngenerate this type implicitly from the GraphQL schema\n.  This event\nhandler returns a \nHandlerResult\n based\non the success of the operation.\n\n\n\n\nHint\n\n\nYou are not limited to notifications in the handle method; you can\ndo whatever you want with your event data!\n\n\n\n\nUnit test\n\u00b6\n\n\nEvent handlers run in the background based on incoming events, so it\u2019s\ncrucial to test so you can be sure that they do what you expect in\nvarious cases.  Event handlers are very unit testable by design.\n\n\nHere is a test for the issue notification event handler:\n\n\nimport\n \n{\n \nEventFired\n \n}\n \nfrom\n \n\"@atomist/automation-client/HandleEvent\"\n;\n\n\nimport\n \n{\n \nHandlerContext\n \n}\n \nfrom\n \n\"@atomist/automation-client/HandlerContext\"\n;\n\n\nimport\n \n{\n \nguid\n \n}\n \nfrom\n \n\"@atomist/automation-client/internal/util/string\"\n;\n\n\nimport\n \n{\n \nMessageOptions\n \n}\n \nfrom\n \n\"@atomist/automation-client/spi/message/MessageClient\"\n;\n\n\nimport\n \n{\n \nMessageClientSupport\n \n}\n \nfrom\n \n\"@atomist/automation-client/spi/message/MessageClientSupport\"\n;\n\n\nimport\n \n{\n \nSlackMessage\n \n}\n \nfrom\n \n\"@atomist/slack-messages/SlackMessages\"\n;\n\n\nimport\n \n\"mocha\"\n;\n\n\nimport\n \n*\n \nas\n \nassert\n \nfrom\n \n\"power-assert\"\n;\n\n\nimport\n \n{\n \nIssueNotification\n \n}\n \nfrom\n \n\"../../../../src/tutorial/lessons/events/IssueNotification\"\n;\n\n\n\ndescribe\n(\n\"IssueNotification\"\n,\n \n()\n \n=>\n \n{\n\n\n    \nconst\n \npayloadNewIssue\n \n=\n \n`{\n\n\n    \"data\": {\n\n\n        \"Issue\": [{\n\n\n            \"number\": 123,\n\n\n            \"title\": \"another bug to fix\",\n\n\n            \"repo\": {\n\n\n                \"owner\": \"negan\",\n\n\n                \"name\": \"saviors\",\n\n\n                \"channels\": [\n\n\n                    {\n\n\n                        \"name\": \"water-cooler-talk\"\n\n\n                    }\n\n\n                ]\n\n\n            }\n\n\n        }]\n\n\n    }\n\n\n}`\n;\n\n\n    \nconst\n \nhandler\n \n=\n \nnew\n \nIssueNotification\n();\n\n\n    \nit\n(\n\"notifies channel\"\n,\n \ndone\n \n=>\n \n{\n\n        \nclass\n \nFakeMessageClient\n \nextends\n \nMessageClientSupport\n \n{\n\n            \nprotected\n \ndoSend\n(\nmsg\n: \nstring\n \n|\n \nSlackMessage\n,\n \nuserNames\n: \nstring\n \n|\n \nstring\n[],\n\n                             \nchannelNames\n: \nstring\n \n|\n \nstring\n[],\n \noptions?\n: \nMessageOptions\n)\n:\n \nPromise\n<\nany\n>\n \n{\n\n                \nassert\n.\ndeepEqual\n(\nmsg\n,\n \n\"New issue: #123 'another bug to fix' in negan.saviors\"\n);\n\n                \nassert\n.\ndeepEqual\n(\nchannelNames\n,\n \n[\n\"water-cooler-talk\"\n]);\n\n                \nreturn\n \nPromise\n.\nresolve\n();\n\n            \n}\n\n        \n}\n\n        \nconst\n \nctx\n: \nHandlerContext\n \n=\n \n{\n\n            \nteamId\n:\n \n\"teamId1\"\n,\n\n            \ncorrelationId\n:\n \n\"correlationId1\"\n,\n\n            \ninvocationId\n: \nguid\n(),\n\n            \ngraphClient\n: \nundefined\n,\n\n            \nmessageClient\n: \nnew\n \nFakeMessageClient\n(),\n\n        \n};\n\n        \nhandler\n.\nhandle\n(\nJSON\n.\nparse\n(\npayloadNewIssue\n)\n \nas\n \nEventFired\n<\nany\n>\n,\n \nctx\n)\n\n            \n.\nthen\n(\ndone\n,\n \ndone\n);\n\n    \n});\n\n\n\n});\n\n\n\n\n\nTo test your event handler, simply call the \nhandle\n method with an\nevent payload like it might see in the wild.  Notice that instead of\nactually sending a message, the sample provides a \nFakeMessageClient\n\n(via the \nHandlerContext\n) where you assert about the way the message\nwould be sent.  A real test should exercise other test cases that are\nnot necessarily the happy path.\n\n\nExamples\n\u00b6\n\n\nRespond to new commits\n\u00b6\n\n\nWhen commits are pushed to GitHub, a Push event is triggered.\n\n\nFor instance, Atomist can run a linter with autofix, and commit the result back to the branch! We run\n\nthis handler\n\nin our teams.\n\n\nThis\n\nsimple handler\n\nsends a message in Slack about a push.\n\n\nComment on an issue\n\u00b6\n\n\nThis handler\n\nalso watches for new or updated GitHub issues. It makes a comment on issues created by you, the runner of the automation\nclient.\n\n\nReact to a failed build\n\u00b6\n\n\nOne of Atomist\u2019s built-in automations sends a DM to the person whose commit\n\nfailed a build.\n\n\nTroubleshooting\n\u00b6\n\n\nAfter unit testing your logic, your best source of information is the log of your automation client. Add \nconsole.log\n calls to your handler as needed.\n\n\nMy event didn\u2019t arrive\n\u00b6\n\n\nFirst, check that your registration completed successfully in the client logs at startup.\n\n\nRun your query in GraphiQL to verify that your event arrived to Atomist. Try adding order-by-timestamp arguments to the\ntop of the query, to see the most recent events that came in.\n\n\n{\n  Issue(orderBy: timestamp_desc, first: 10) {\n    number\n    timestamp\n  }\n}\n\n\n\n\nMy handler didn\u2019t do what I expected\n\u00b6\n\n\nEnsure that the type of your incoming EventFired object matches the structure that you see in the query. Write unit tests that take events with the same structure and be sure to test corner cases. You can run the client locally in a debugger and trigger the events to see what is happening.",
            "title": "Events"
        },
        {
            "location": "/developer/events/#event-handler-structure",
            "text": "Here is a complete event handler that listens for new issues and\nnotifies you.  import   {   EventHandler   }   from   \"@atomist/automation-client/decorators\" ;  import   {   EventFired ,   HandleEvent   }   from   \"@atomist/automation-client/HandleEvent\" ;  import   {   HandlerContext   }   from   \"@atomist/automation-client/HandlerContext\" ;  import   { \n     failure , \n     HandlerResult , \n     success  }   from   \"@atomist/automation-client/HandlerResult\" ;  @EventHandler ( \"Notify channel on new issue\" , \n     `subscription IssueNotification  {    Issue(state: open) {      number      title      repo {        owner        name        channels {          name        }      }    }  }` )  export   class   IssueNotification   implements   HandleEvent < Issues >   { \n     public   handle ( e :  EventFired < Issues > ,   ctx :  HandlerContext ) :   Promise < HandlerResult >   { \n         const   issue   =   e . data . Issue [ 0 ]; \n         return   ctx . messageClient . addressChannels ( \n             `New issue: # ${ issue . number }  ' ${ issue . title } ' in  ${ issue . repo . owner } . ${ issue . repo . name } ` , \n             issue . repo . channels . map ( c   =>   c . name ) \n         ) \n             . then ( success ,   failure ); \n     }  }  export   interface   Issues   { \n     Issue :   [{ \n         number :   number ; \n         title :  string ; \n         repo :   { \n             owner :  string ; \n             name :  string ; \n             channels :   [{ \n                 name :  string ; \n             }] \n         } \n     }]  }   The  @EventHandler  decorator allows you to provide a description and\na query to subscribe to. Notice the GraphQL that you built up in the\nprevious section.  You\ncan  define the subscription GraphQL query  inline\nor reference a file. It also implements  HandleEvent  which specifies\nthe handle method.  This is where your automation code goes. Every\nmatching event triggers the code here.  From here you have access to\nthe event itself with  EventFired  and\na  HandlerContext  for interacting with Slack or\nquerying more events.  While a command handler has  @Parameters  and @MappedParamters  to specify the details on invocation, an event\nhandler does not.  Instead it acts on the data inside the event.  This example uses the  HandlerContext  to send a message about the new\nissue to any associated channels it has.  Most of the work is done\njust by the subscription query that provides the data the event\nhandler needs.  The  Issues  interface exists merely for the\nconvenience of having a typed  EventFired , but there are ways to generate this type implicitly from the GraphQL schema .  This event\nhandler returns a  HandlerResult  based\non the success of the operation.   Hint  You are not limited to notifications in the handle method; you can\ndo whatever you want with your event data!",
            "title": "Event handler structure"
        },
        {
            "location": "/developer/events/#unit-test",
            "text": "Event handlers run in the background based on incoming events, so it\u2019s\ncrucial to test so you can be sure that they do what you expect in\nvarious cases.  Event handlers are very unit testable by design.  Here is a test for the issue notification event handler:  import   {   EventFired   }   from   \"@atomist/automation-client/HandleEvent\" ;  import   {   HandlerContext   }   from   \"@atomist/automation-client/HandlerContext\" ;  import   {   guid   }   from   \"@atomist/automation-client/internal/util/string\" ;  import   {   MessageOptions   }   from   \"@atomist/automation-client/spi/message/MessageClient\" ;  import   {   MessageClientSupport   }   from   \"@atomist/automation-client/spi/message/MessageClientSupport\" ;  import   {   SlackMessage   }   from   \"@atomist/slack-messages/SlackMessages\" ;  import   \"mocha\" ;  import   *   as   assert   from   \"power-assert\" ;  import   {   IssueNotification   }   from   \"../../../../src/tutorial/lessons/events/IssueNotification\" ;  describe ( \"IssueNotification\" ,   ()   =>   { \n\n     const   payloadNewIssue   =   `{      \"data\": {          \"Issue\": [{              \"number\": 123,              \"title\": \"another bug to fix\",              \"repo\": {                  \"owner\": \"negan\",                  \"name\": \"saviors\",                  \"channels\": [                      {                          \"name\": \"water-cooler-talk\"                      }                  ]              }          }]      }  }` ; \n\n     const   handler   =   new   IssueNotification (); \n\n     it ( \"notifies channel\" ,   done   =>   { \n         class   FakeMessageClient   extends   MessageClientSupport   { \n             protected   doSend ( msg :  string   |   SlackMessage ,   userNames :  string   |   string [], \n                              channelNames :  string   |   string [],   options? :  MessageOptions ) :   Promise < any >   { \n                 assert . deepEqual ( msg ,   \"New issue: #123 'another bug to fix' in negan.saviors\" ); \n                 assert . deepEqual ( channelNames ,   [ \"water-cooler-talk\" ]); \n                 return   Promise . resolve (); \n             } \n         } \n         const   ctx :  HandlerContext   =   { \n             teamId :   \"teamId1\" , \n             correlationId :   \"correlationId1\" , \n             invocationId :  guid (), \n             graphClient :  undefined , \n             messageClient :  new   FakeMessageClient (), \n         }; \n         handler . handle ( JSON . parse ( payloadNewIssue )   as   EventFired < any > ,   ctx ) \n             . then ( done ,   done ); \n     });  });   To test your event handler, simply call the  handle  method with an\nevent payload like it might see in the wild.  Notice that instead of\nactually sending a message, the sample provides a  FakeMessageClient \n(via the  HandlerContext ) where you assert about the way the message\nwould be sent.  A real test should exercise other test cases that are\nnot necessarily the happy path.",
            "title": "Unit test"
        },
        {
            "location": "/developer/events/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/developer/events/#respond-to-new-commits",
            "text": "When commits are pushed to GitHub, a Push event is triggered.  For instance, Atomist can run a linter with autofix, and commit the result back to the branch! We run this handler \nin our teams.  This simple handler \nsends a message in Slack about a push.",
            "title": "Respond to new commits"
        },
        {
            "location": "/developer/events/#comment-on-an-issue",
            "text": "This handler \nalso watches for new or updated GitHub issues. It makes a comment on issues created by you, the runner of the automation\nclient.",
            "title": "Comment on an issue"
        },
        {
            "location": "/developer/events/#react-to-a-failed-build",
            "text": "One of Atomist\u2019s built-in automations sends a DM to the person whose commit failed a build.",
            "title": "React to a failed build"
        },
        {
            "location": "/developer/events/#troubleshooting",
            "text": "After unit testing your logic, your best source of information is the log of your automation client. Add  console.log  calls to your handler as needed.",
            "title": "Troubleshooting"
        },
        {
            "location": "/developer/events/#my-event-didnt-arrive",
            "text": "First, check that your registration completed successfully in the client logs at startup.  Run your query in GraphiQL to verify that your event arrived to Atomist. Try adding order-by-timestamp arguments to the\ntop of the query, to see the most recent events that came in.  {\n  Issue(orderBy: timestamp_desc, first: 10) {\n    number\n    timestamp\n  }\n}",
            "title": "My event didn't arrive"
        },
        {
            "location": "/developer/events/#my-handler-didnt-do-what-i-expected",
            "text": "Ensure that the type of your incoming EventFired object matches the structure that you see in the query. Write unit tests that take events with the same structure and be sure to test corner cases. You can run the client locally in a debugger and trigger the events to see what is happening.",
            "title": "My handler didn't do what I expected"
        },
        {
            "location": "/developer/slack/",
            "text": "Atomist supports sending \nrich\n, \nactionable\n and \nupdatable\n Slack messages. Messages can be sent by an event handler or a command handler.\n\n\n\n\nRich\n messages take full advantage of Slack\u2019s native message formatting capabilities\n\n\nActionable\n messages contain buttons and menus that trigger new commands on behalf of the user who clicked them\n\n\nUpdatable\n messages can be rewritten with new content over time in response to new events\nand actions. This helps reduce the number of messages from the Atomist bot in a Slack channel.\n\n\n\n\nHere\u2019s an example of a message with different \nAttachments\n and\n\nActions\n from the Atomist open source community Slack team.\n\n\n\n\nIf you\u2019re not familiar with the main concepts of Slack message formatting, you may want to read \nSlack\u2019s documentation\n before you read the following sections.\n\n\nMessageClient interface\n\u00b6\n\n\nLet\u2019s take a look at the \nMessageClient\n interface.\n\n\nexport\n \ninterface\n \nMessageClient\n \n{\n\n\n    \nrespond\n(\nmsg\n: \nstring\n \n|\n \nSlackMessage\n,\n \noptions?\n: \nMessageOptions\n)\n:\n \nPromise\n<\nany\n>\n;\n\n\n    \naddressUsers\n(\nmsg\n: \nstring\n \n|\n \nSlackMessage\n,\n \nuserNames\n: \nstring\n \n|\n \nstring\n[],\n\n                 \noptions?\n: \nMessageOptions\n)\n:\n \nPromise\n<\nany\n>\n;\n\n\n    \naddressChannels\n(\nmsg\n: \nstring\n \n|\n \nSlackMessage\n,\n \nchannelNames\n: \nstring\n \n|\n \nstring\n[],\n\n                    \noptions?\n: \nMessageOptions\n)\n:\n \nPromise\n<\nany\n>\n;\n\n\n    \n...\n\n\n}\n\n\n\n\n\nThe \nMessageClient\n provides access to methods for sending messages to Slack. It\nallows you to address messages to users or channels by name or to simply send a\nresponse message.\n\n\nGenerally the \nMessageClient\n is available from the \nHandlerContext\n parameter\nto the \nhandle\n method of \ncommand\n and event handlers.\n\n\nResponse messages\n\u00b6\n\n\nA response message is a message that is sent while handling a request to\nrun a certain command; they can therefore only be sent by command handlers.\nUse the \nrespond\n method to sending a response message. The Atomist platform takes\ncare of delivering the message into the right conversation in Slack.\n\n\nThe following example shows how to send a response message from a command handler.\n\n\nexport\n \nclass\n \nHelloWorld\n \nimplements\n \nHandleCommand\n \n{\n\n\n    \npublic\n \nhandle\n(\nctx\n: \nHandlerContext\n)\n:\n \nPromise\n<\nHandlerResult\n>\n \n{\n\n        \nreturn\n \nctx\n.\nmessageClient\n.\nrespond\n(\n\"Hello from Atomist\"\n)\n\n            \n.\nthen\n(()\n \n=>\n \nSuccess\n,\n \nfailure\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nUser and channel messages\n\u00b6\n\n\nAddress messages to users by calling the \naddressUsers\n method,\nproviding one or more names of Slack users. To send a message to one\nor more channels, call the \naddressChannels\n method.\n\n\n\n\nNote\n\n\nIf you want to send a direct message to a user in your Slack team, use the\n\naddressUsers\n method with the user name of the recipient.\n\n\n\n\nHere is an example of sending a simple message into the \n#general\n channel of\nyour Slack team:\n\n\nexport\n \nclass\n \nHelloWorld\n \nimplements\n \nHandleCommand\n \n{\n\n\n    \npublic\n \nhandle\n(\nctx\n: \nHandlerContext\n)\n:\n \nPromise\n<\nHandlerResult\n>\n \n{\n\n        \nreturn\n \nctx\n.\nmessageClient\n.\naddressChannels\n(\n\"Hello from Atomist\"\n,\n \n\"general\"\n)\n\n            \n.\nthen\n(()\n \n=>\n \nSuccess\n,\n \nfailure\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nIn this example, you are sending the message only to the \n#general\n channel. It is\npossible to send the same message into more than one channel by simply providing\nan array of channel names to the \naddressChannels\n method. The same works for\n\naddressUsers\n.\n\n\nFormatting messages\n\u00b6\n\n\nIn the previous section you saw how to address and send messages to Slack. This section covers\nformatting simple and complex Slack messages. It also demonstrates how to add buttons and menus to messages.\n\n\nSimple messages\n\u00b6\n\n\nThe \naddressUsers\n, \naddressChannels\n and \nrespond\n methods accept a \nstring\n\nmessage as first argument. A simple \nstring\n message can still have some basic\nformatting.\n\n\nHere are a couple of examples of simple messages:\n\n\n\n\n\n\n\n\nCode\n\n\nOutput\n\n\n\n\n\n\n\n\n\n\nmessageClient.respond(\"This is a plain message\");\n\n\nThis is a plan message\n\n\n\n\n\n\nmessageClient.respond(\"This some *bold* text\");\n\n\nThis is some \nbold\n text\n\n\n\n\n\n\nmessageClient.respond(\"This some _italics_ text\");\n\n\nThis is some \nitalics\n text\n\n\n\n\n\n\nmessageClient.respond(\"Some multiline\\ntext\");\n\n\nSome multiline\ntext\n\n\n\n\n\n\n\n\nMore details on Slack text formatting can be found their the \ndocumentation\n.\n\n\nRich messages\n\u00b6\n\n\nFor more complex, rich messages, Atomist provides the \nSlackMessage\n type as\npart of the \n@atomist/slack-messages\n NPM module.\n\n\nThe \nSlackMessage\n type can have \nAttachments\n and \nActions\n. More details\non those concepts can be found in the \nSlack documentation\n.\n\n\nIn order to create a formatted Slack message, simply build an instance of\n\nSlackMessage\n with all desired properties. Here is an example:\n\n\nimport\n \n*\n \nas\n \nslack\n \nfrom\n \n\"@atomist/slack-messages\"\n;\n\n\n\nconst\n \nmessage\n: \nslack.SlackMessage\n \n=\n \n{\n\n  \nattachments\n:\n \n[{\n\n    \nfallback\n:\n \n\"How to filter by parent or ancestor directory with sysdig\"\n,\n\n    \nauthor_name\n:\n \n\"Janek Bogucki\"\n,\n\n    \nauthor_link\n:\n \n\"https://stackoverflow.com/users/148440/janek-bogucki\"\n,\n\n    \nauthor_icon\n:\n \n\"https://www.gravatar.com/avatar/5ccd05d83049593205406ac74eacb323?s=128&d=identicon&r=PG\"\n,\n\n    \ntitle\n:\n \n\"How to filter by parent or ancestor directory withsysdig\"\n,\n\n    \ntitle_link\n:\n \n\"https://stackoverflow.com/questions/41827350/how-to-filter-by-parent-or-ancestor-directory-with-sysdig\"\n,\n\n    \nthumb_url\n:\n \n\"https://slack-imgs.com/?c=1&o1=wi75.he75&url=https%3A%2F%2Fcdn.sstatic.net%2FSites%2Fstackoverflow%2Fimg%2Fapple-touch-icon%402.png%3Fv%3D73d79a89bded\"\n,\n\n    \nfooter\n:\n \n\"file, sysdig\"\n,\n\n    \nts\n: \n1485258115\n\n  \n},\n \n{\n\n    \nfallback\n:\n \n\"Show more...\"\n,\n\n    \ntitle\n:\n \n\"Show more...\"\n,\n\n    \ntitle_link\n:\n \n\"http://stackoverflow.com/search?order=desc&sort=relevance&q=atomist\"\n\n  \n}]\n\n\n};\n\n\n\nOnce the \nSlackMessage\n is created you can send it via the \nMessageClient\n:\n\n\nctx\n.\nmessageClient\n.\nrespond\n(\nmessage\n);\n\n\n\nThis renders the following in Slack:\n\n\n\n\nAdding message buttons\n\u00b6\n\n\nIn the previous section you saw how rich messages can be created and posted to\nSlack. Now you\u2019ll see how to turn this message into an actionable message by adding a\nbutton to it.\n\n\nWith Atomist, it\u2019s easy to bind Slack action buttons to command handlers. Such a\nbinding consists of three parts: the specification of the button as required by\nSlack, a reference to the \ncommand handler\n, and optional parameters that should be\npre-populated when invoking the command.\n\n\nThe button specification is defined by Slack in the \nfield guide\n.\nHere is an example of a button with a confirmation pop-up:\n\n\nimport\n \n{\n \nButtonSpecification\n \n}\n \nfrom\n \n\"@atomist/automation-client/spi/message/MessageClient\"\n;\n\n\n\nconst\n \nbuttonSpec\n: \nButtonSpecification\n \n=\n \n{\n\n    \ntext\n:\n \n\"Search Again\"\n,\n\n    \nconfirm\n:\n \n{\n\n        \ntitle\n:\n \n\"Search Again?\"\n,\n\n        \ntext\n:\n \n\"Do you really want to run the search again?\"\n,\n\n        \ndismiss_text\n:\n \n\"No\"\n,\n\n        \nok_text\n:\n \n\"Yes\"\n\n    \n},\n\n\n};\n\n\n\n\n\nWith the following, you\u2019re preparing a \ncommand handler\n and its parameter to be\nbound to the button. This example uses the \nSearchStackOverflow\n\ncommand handler from the Atomist \nblog series\n.\n\n\nconst\n \nhandler\n \n=\n \nnew\n \nSearchStackOverflow\n();\n\n\nhandler\n.\nq\n \n=\n \n\"atomist\"\n;\n\n\n\n\n\nNow that you have the \nButtonSpecification\n and the command handler, you can bring this\nall together into a Slack message button and send the message. Create the action\nbutton by calling the \nbuttonForCommand\n function, passing the\n\nButtonSpecification\n and the command handler instance:\n\n\nimport\n \n{\n \nbuttonForCommand\n \n}\n \nfrom\n \n\"@atomist/automation-client/spi/message/MessageClient\"\n;\n\n\n\nconst\n \nmessage\n: \nslack.SlackMessage\n \n=\n \n{\n\n    \nattachments\n:\n \n[{\n\n        \n// ...\n\n    \n},\n \n{\n\n        \nfallback\n:\n \n\"Show more...\"\n,\n\n        \ntitle\n:\n \n\"Show more...\"\n,\n\n        \ntitle_link\n:\n \n\"http://stackoverflow.com/search?order=desc&sort=relevance&q=atomist\"\n,\n\n        \nactions\n:\n \n[\n\n          \nbuttonForCommand\n(\nbuttonSpec\n,\n \nhandler\n),\n\n        \n],\n\n    \n}],\n\n\n};\n\n\n\nreturn\n \nctx\n.\nmessageClient\n.\nrespond\n(\nmessage\n)\n\n    \n.\nthen\n(()\n \n=>\n \nSuccess\n,\n \nfailure\n);\n\n\n\n\n\nAdding message menus\n\u00b6\n\n\nMessage menus are very similar to message buttons in the way they are created and\nadded to the message. The main difference is that menus are defined with a \nMenuSpecification\n\ninstead of a \nButtonSpecification\n.\n\n\nBesides the name of the menu, a \nMenuSpecification\n allows you to define menu options\nand option groups.\n\n\nSee the following example:\n\n\nimport\n \n{\n \nMenuSpecification\n \n}\n \nfrom\n \n\"@atomist/automation-client/spi/message/MessageClient\"\n;\n\n\n\nconst\n \nmenuSpec\n: \nMenuSpecification\n \n=\n \n{\n\n    \ntext\n:\n \n\"Issue Labels\"\n,\n\n    \noptions\n:\n \n[{\n\n        \ntext\n:\n \n\"Bug\"\n,\n \nvalue\n:\n \n\"bug\"\n,\n\n    \n},\n \n{\n\n        \ntext\n:\n \n\"Enhancement\"\n,\n \nvalue\n:\n \n\"enhancement\"\n,\n\n    \n},\n \n{\n\n        \ntext\n:\n \n\"Invalid\"\n,\n \nvalue\n:\n \n\"invalid\"\n,\n\n    \n}],\n\n\n};\n\n\n\nconst\n \nmessage\n: \nslack.SlackMessage\n \n=\n \n{\n\n    \nattachments\n:\n \n[{\n\n        \n// ...\n\n        \nactions\n:\n \n[\n\n          \nmenuForCommand\n(\nmenuSpec\n,\n \nhandler\n,\n \n\"label\"\n),\n\n        \n],\n\n    \n}],\n\n\n};\n\n\n\n\n\nTo create the menu, \nmenuForCommand\n is called with the menu details, the reference\nto the command handler and the name of the parameter on the command handler that\nthe selected value of the menu should be bound to; in this example, the value of\nthe option will be bound to the \nlabel\n parameter.\n\n\nMessage options\n\u00b6\n\n\nWith \nMessageOptions\n actionable Slack message can be turned into \nupdatable\n\nmessages; the \nMessageOptions\n interface provides important options to handle\nand tune message updates and rewrites in Slack.\n\n\nThe following section describes the properties on the \nMessageOptions\n\ninterface and what they can be used for. But first, here is the interface:\n\n\nexport\n \ninterface\n \nMessageOptions\n \n{\n\n\n    \n/**\n\n\n     * Unique message id per channel and team. This is required\n\n\n     * if you wish to re-write a message at a later time.\n\n\n     */\n\n    \nid?\n: \nstring\n;\n\n\n    \n/**\n\n\n     * Timestamp of the message. The timestamp needs to be\n\n\n     * sortable lexicographically. Should be in milliseconds and\n\n\n     * defaults to Date.now().\n\n\n     *\n\n\n     * This is only applicable if id is set too.\n\n\n     */\n\n    \nts?\n: \nnumber\n;\n\n\n    \n/**\n\n\n     * Time to live for a posted message. If ts + ttl of the\n\n\n     * existing message with ts is < as a new incoming message\n\n\n     * with the same id, the message will be re-written.\n\n\n     */\n\n    \nttl?\n: \nnumber\n;\n\n\n    \n/**\n\n\n     * If update_only is given, this message will only be posted\n\n\n     * if a previous message with the same id exists.\n\n\n     */\n\n    \npost\n?:\n \n\"update_only\"\n \n|\n \n\"always\"\n;\n\n\n}\n\n\n\n\n\nThe \nid\n property uniquely identifies a message in a channel or\ndirect message. It therefore must be unique in the scope of a channel\nor direct message.\n\n\nts\n specifies the time in milliseconds of the message. If not set, it\ndefaults to the current time. This property is important to maintain correct\norder of messages: the Atomist bot will not post a message with a \nts\n\nif there is a message for the same \nid\n but a later \nts\n already in the channel\nor direct message.\n\n\nttl\n or time-to-live defines the amount of time in milliseconds that a message can be updated, after which a new instance of the message is posted to the bottom of the Slack stream. So, when a message is received by the bot,\nit compares the \nts + ttl\n of the existing message with \nts\n of the new\nmessage; if \nts + ttl\n is smaller, a new message ia posted to the bottom\nof the Slack stream and the existing message is not rewritten. As long \nts + ttl\n\nis greater then \nts\n of the new message, the existing message will be overwritten.\n\n\nLastly, the \npost\n property specifies whether a message should be posted only if\nit is an update to a previously posted message with the same \nid\n. If\n\npost === \"always\"\n, the message is always posted as a new message and never rewrites\na previous message.\nwill never rewrite a previous message.",
            "title": "Slack Messages"
        },
        {
            "location": "/developer/slack/#messageclient-interface",
            "text": "Let\u2019s take a look at the  MessageClient  interface.  export   interface   MessageClient   { \n\n     respond ( msg :  string   |   SlackMessage ,   options? :  MessageOptions ) :   Promise < any > ; \n\n     addressUsers ( msg :  string   |   SlackMessage ,   userNames :  string   |   string [], \n                  options? :  MessageOptions ) :   Promise < any > ; \n\n     addressChannels ( msg :  string   |   SlackMessage ,   channelNames :  string   |   string [], \n                     options? :  MessageOptions ) :   Promise < any > ; \n\n     ...  }   The  MessageClient  provides access to methods for sending messages to Slack. It\nallows you to address messages to users or channels by name or to simply send a\nresponse message.  Generally the  MessageClient  is available from the  HandlerContext  parameter\nto the  handle  method of  command  and event handlers.",
            "title": "MessageClient interface"
        },
        {
            "location": "/developer/slack/#response-messages",
            "text": "A response message is a message that is sent while handling a request to\nrun a certain command; they can therefore only be sent by command handlers.\nUse the  respond  method to sending a response message. The Atomist platform takes\ncare of delivering the message into the right conversation in Slack.  The following example shows how to send a response message from a command handler.  export   class   HelloWorld   implements   HandleCommand   { \n\n     public   handle ( ctx :  HandlerContext ) :   Promise < HandlerResult >   { \n         return   ctx . messageClient . respond ( \"Hello from Atomist\" ) \n             . then (()   =>   Success ,   failure ); \n     }  }",
            "title": "Response messages"
        },
        {
            "location": "/developer/slack/#user-and-channel-messages",
            "text": "Address messages to users by calling the  addressUsers  method,\nproviding one or more names of Slack users. To send a message to one\nor more channels, call the  addressChannels  method.   Note  If you want to send a direct message to a user in your Slack team, use the addressUsers  method with the user name of the recipient.   Here is an example of sending a simple message into the  #general  channel of\nyour Slack team:  export   class   HelloWorld   implements   HandleCommand   { \n\n     public   handle ( ctx :  HandlerContext ) :   Promise < HandlerResult >   { \n         return   ctx . messageClient . addressChannels ( \"Hello from Atomist\" ,   \"general\" ) \n             . then (()   =>   Success ,   failure ); \n     }  }   In this example, you are sending the message only to the  #general  channel. It is\npossible to send the same message into more than one channel by simply providing\nan array of channel names to the  addressChannels  method. The same works for addressUsers .",
            "title": "User and channel messages"
        },
        {
            "location": "/developer/slack/#formatting-messages",
            "text": "In the previous section you saw how to address and send messages to Slack. This section covers\nformatting simple and complex Slack messages. It also demonstrates how to add buttons and menus to messages.",
            "title": "Formatting messages"
        },
        {
            "location": "/developer/slack/#simple-messages",
            "text": "The  addressUsers ,  addressChannels  and  respond  methods accept a  string \nmessage as first argument. A simple  string  message can still have some basic\nformatting.  Here are a couple of examples of simple messages:     Code  Output      messageClient.respond(\"This is a plain message\");  This is a plan message    messageClient.respond(\"This some *bold* text\");  This is some  bold  text    messageClient.respond(\"This some _italics_ text\");  This is some  italics  text    messageClient.respond(\"Some multiline\\ntext\");  Some multiline text     More details on Slack text formatting can be found their the  documentation .",
            "title": "Simple messages"
        },
        {
            "location": "/developer/slack/#rich-messages",
            "text": "For more complex, rich messages, Atomist provides the  SlackMessage  type as\npart of the  @atomist/slack-messages  NPM module.  The  SlackMessage  type can have  Attachments  and  Actions . More details\non those concepts can be found in the  Slack documentation .  In order to create a formatted Slack message, simply build an instance of SlackMessage  with all desired properties. Here is an example:  import   *   as   slack   from   \"@atomist/slack-messages\" ;  const   message :  slack.SlackMessage   =   { \n   attachments :   [{ \n     fallback :   \"How to filter by parent or ancestor directory with sysdig\" , \n     author_name :   \"Janek Bogucki\" , \n     author_link :   \"https://stackoverflow.com/users/148440/janek-bogucki\" , \n     author_icon :   \"https://www.gravatar.com/avatar/5ccd05d83049593205406ac74eacb323?s=128&d=identicon&r=PG\" , \n     title :   \"How to filter by parent or ancestor directory withsysdig\" , \n     title_link :   \"https://stackoverflow.com/questions/41827350/how-to-filter-by-parent-or-ancestor-directory-with-sysdig\" , \n     thumb_url :   \"https://slack-imgs.com/?c=1&o1=wi75.he75&url=https%3A%2F%2Fcdn.sstatic.net%2FSites%2Fstackoverflow%2Fimg%2Fapple-touch-icon%402.png%3Fv%3D73d79a89bded\" , \n     footer :   \"file, sysdig\" , \n     ts :  1485258115 \n   },   { \n     fallback :   \"Show more...\" , \n     title :   \"Show more...\" , \n     title_link :   \"http://stackoverflow.com/search?order=desc&sort=relevance&q=atomist\" \n   }]  };  \nOnce the  SlackMessage  is created you can send it via the  MessageClient :  ctx . messageClient . respond ( message );  \nThis renders the following in Slack:",
            "title": "Rich messages"
        },
        {
            "location": "/developer/slack/#adding-message-buttons",
            "text": "In the previous section you saw how rich messages can be created and posted to\nSlack. Now you\u2019ll see how to turn this message into an actionable message by adding a\nbutton to it.  With Atomist, it\u2019s easy to bind Slack action buttons to command handlers. Such a\nbinding consists of three parts: the specification of the button as required by\nSlack, a reference to the  command handler , and optional parameters that should be\npre-populated when invoking the command.  The button specification is defined by Slack in the  field guide .\nHere is an example of a button with a confirmation pop-up:  import   {   ButtonSpecification   }   from   \"@atomist/automation-client/spi/message/MessageClient\" ;  const   buttonSpec :  ButtonSpecification   =   { \n     text :   \"Search Again\" , \n     confirm :   { \n         title :   \"Search Again?\" , \n         text :   \"Do you really want to run the search again?\" , \n         dismiss_text :   \"No\" , \n         ok_text :   \"Yes\" \n     },  };   With the following, you\u2019re preparing a  command handler  and its parameter to be\nbound to the button. This example uses the  SearchStackOverflow \ncommand handler from the Atomist  blog series .  const   handler   =   new   SearchStackOverflow ();  handler . q   =   \"atomist\" ;   Now that you have the  ButtonSpecification  and the command handler, you can bring this\nall together into a Slack message button and send the message. Create the action\nbutton by calling the  buttonForCommand  function, passing the ButtonSpecification  and the command handler instance:  import   {   buttonForCommand   }   from   \"@atomist/automation-client/spi/message/MessageClient\" ;  const   message :  slack.SlackMessage   =   { \n     attachments :   [{ \n         // ... \n     },   { \n         fallback :   \"Show more...\" , \n         title :   \"Show more...\" , \n         title_link :   \"http://stackoverflow.com/search?order=desc&sort=relevance&q=atomist\" , \n         actions :   [ \n           buttonForCommand ( buttonSpec ,   handler ), \n         ], \n     }],  };  return   ctx . messageClient . respond ( message ) \n     . then (()   =>   Success ,   failure );",
            "title": "Adding message buttons"
        },
        {
            "location": "/developer/slack/#adding-message-menus",
            "text": "Message menus are very similar to message buttons in the way they are created and\nadded to the message. The main difference is that menus are defined with a  MenuSpecification \ninstead of a  ButtonSpecification .  Besides the name of the menu, a  MenuSpecification  allows you to define menu options\nand option groups.  See the following example:  import   {   MenuSpecification   }   from   \"@atomist/automation-client/spi/message/MessageClient\" ;  const   menuSpec :  MenuSpecification   =   { \n     text :   \"Issue Labels\" , \n     options :   [{ \n         text :   \"Bug\" ,   value :   \"bug\" , \n     },   { \n         text :   \"Enhancement\" ,   value :   \"enhancement\" , \n     },   { \n         text :   \"Invalid\" ,   value :   \"invalid\" , \n     }],  };  const   message :  slack.SlackMessage   =   { \n     attachments :   [{ \n         // ... \n         actions :   [ \n           menuForCommand ( menuSpec ,   handler ,   \"label\" ), \n         ], \n     }],  };   To create the menu,  menuForCommand  is called with the menu details, the reference\nto the command handler and the name of the parameter on the command handler that\nthe selected value of the menu should be bound to; in this example, the value of\nthe option will be bound to the  label  parameter.",
            "title": "Adding message menus"
        },
        {
            "location": "/developer/slack/#message-options",
            "text": "With  MessageOptions  actionable Slack message can be turned into  updatable \nmessages; the  MessageOptions  interface provides important options to handle\nand tune message updates and rewrites in Slack.  The following section describes the properties on the  MessageOptions \ninterface and what they can be used for. But first, here is the interface:  export   interface   MessageOptions   { \n\n     /**       * Unique message id per channel and team. This is required       * if you wish to re-write a message at a later time.       */ \n     id? :  string ; \n\n     /**       * Timestamp of the message. The timestamp needs to be       * sortable lexicographically. Should be in milliseconds and       * defaults to Date.now().       *       * This is only applicable if id is set too.       */ \n     ts? :  number ; \n\n     /**       * Time to live for a posted message. If ts + ttl of the       * existing message with ts is < as a new incoming message       * with the same id, the message will be re-written.       */ \n     ttl? :  number ; \n\n     /**       * If update_only is given, this message will only be posted       * if a previous message with the same id exists.       */ \n     post ?:   \"update_only\"   |   \"always\" ;  }   The  id  property uniquely identifies a message in a channel or\ndirect message. It therefore must be unique in the scope of a channel\nor direct message.  ts  specifies the time in milliseconds of the message. If not set, it\ndefaults to the current time. This property is important to maintain correct\norder of messages: the Atomist bot will not post a message with a  ts \nif there is a message for the same  id  but a later  ts  already in the channel\nor direct message.  ttl  or time-to-live defines the amount of time in milliseconds that a message can be updated, after which a new instance of the message is posted to the bottom of the Slack stream. So, when a message is received by the bot,\nit compares the  ts + ttl  of the existing message with  ts  of the new\nmessage; if  ts + ttl  is smaller, a new message ia posted to the bottom\nof the Slack stream and the existing message is not rewritten. As long  ts + ttl \nis greater then  ts  of the new message, the existing message will be overwritten.  Lastly, the  post  property specifies whether a message should be posted only if\nit is an update to a previously posted message with the same  id . If post === \"always\" , the message is always posted as a new message and never rewrites\na previous message.\nwill never rewrite a previous message.",
            "title": "Message options"
        },
        {
            "location": "/developer/graphql/",
            "text": "GraphQL\n is a powerful query language that you use to query\nand mutate your data in the Atomist automation platform.\n\n\nBesides being a great query language, GraphQL provides great tool support based\non strongly-typed schemas, type generation for TypeScript, and many other\nadvantages.\n\n\nThe following sections tell you how to use GraphQL to query your data,\nhow to use subscriptions to get notifications when new data is ingested, and\nhow to mutate data.\n\n\nAccessing data with GraphiQL\n\u00b6\n\n\nGraphiQL\n is a GraphQL client\nthat helps you write queries and displays the shape of the resulting\ndata. It also provides access to the data model\u2019s documentation.\n\n\n\n\nNote\n\n\nOn macOS it\u2019s easiest to install GraphiQL as a stand-alone app\nfrom \nhttps://github.com/skevy/graphiql-app\n.\n\n\n\n\nAfter installation you need to configure the endpoint and authentication in GraphiQL.\n\n\nTo setup authentication, click on \nEdit HTTP Headers\n and select \n+ Add Header\n.\nEnter \nAuthorization\n as \nHeader name\n and \nBearer <token>\n as \nHeader value\n.\nReplace \n<token>\n with a GitHub personal access token that has \norg:read\n scope.\n\n\n\n\nNote\n\n\nCreate and manage GitHub personal access tokens at:\n\nhttps://github.com/settings/tokens\n\n\n\n\nNext, enter \nhttps://automation.atomist.com/graphql/team/<teamId>\n as \nGraphQL\nEndpoint\n replacing \n<teamId>\n with your Slack team ID. See the Setup section\non how to obtain your Slack team ID.\n\n\nNow you are ready to create queries and explore the possibilities of the\nAtomist data model. Don\u2019t miss the schema documentation on the right hand side\nof GraphiQL.\n\n\nQueries\n\u00b6\n\n\nYou can execute queries from command and event handlers when running an Atomist\nautomation client. To execute queries, the client provides two distinct methods\non \nGraphClient\n. A \nGraphClient\n is available from the \nHandlerContext\n.\n\n\nYou can use \nexecuteQuery\n to run a GraphQL query from a \nstring\n instance.\nAlternatively, you can can use the \nexecuteQueryFromFile\n method to load and\nrun queries stored in \n*.graphql\n files.\n\n\n\n\nNote\n\n\nExternalizing queries makes it possible to generate types for use in\nyour TypeScript code. More on that later.\n\n\n\n\nThe following example shows you how to query for pushes and see all corresponding\ncontinuous integration builds.\n\n\nStart by creating the query. The sample query includes a variable and a predicate that\nmatches only failed builds. This example assumes the query is saved in\na file called \npushesWithFailedBuilds.graphql\n.\n\n\nquery PushesWithFailedBuilds ($name: String!) {\n  Push {\n    repo(name: $name) {\n      name\n      owner\n    }\n    builds(status: failed) {\n      name\n      status\n      buildUrl\n    }\n  }\n}\n\n\n\n\nOnce the query is defined, you can use it with the \nGraphClient\n to execute\na query.\n\n\npublic\n \nhandle\n(\nctx\n: \nHandlerContext\n)\n:\n \nPromise\n<\nHandlerResult\n>\n \n{\n\n\n    \nctx\n.\ngraphClient\n.\nexecuteQueryFromFile\n(\n\"pushesWithFailedBuilds\"\n,\n\n        \n{\n \nname\n:\n \n\"demo-service\"\n \n},\n \n__dirname\n)\n\n        \n.\nthen\n(\nresult\n \n=>\n \n{\n\n            \n// Do something with the query result\n\n        \n},\n \nfailure\n);\n\n\n    \n// ....\n\n\n}\n\n\n\nThe \nexecuteQueryFromFile\n method takes the relative path to the external query\nfile as first parameter. The second parameter in the above example is the value for\nthe query variable. Lastly we specify \n__dirname\n to pass over the full path of\nthe current script which is needed to resolve the relative reference to the\n\n.graphql\n file.\n\n\nSubscriptions\n\u00b6\n\n\nAs detailed in the section on event handlers, GraphQL subscriptions can be used\nto \nsubscribe\n to events as they get ingested into the Atomist platform.\n\n\nSubscriptions can\u2019t be executed with the \nGraphClient\n; instead they can only\nbe used from the \n@EventHandler\n decorator.\n\n\nThere are two ways to declare subscriptions on event handlers: either\nby embedded strings or by referencing external files, which is more reusable.\n\n\nThis example demonstrates subscribing using an external file:\n\n\nsubscription PushesWithFailedBuilds {\n  Push {\n    repo {\n      name\n      owner\n    }\n    builds(status: failed) {\n      name\n      status\n      buildUrl\n    }\n  }\n}\n\n\n\n\nA GraphQL subscription begins with the keyword \nsubscription\n followed\nby a name for the subscription, \nPushesWithFailedBuilds\n in this case.\nAfter the opening brace, you specify the type of the top-level event\nyou are subscribing to, \nPush\n in this example.  Your subscription\nthen defines the structured data you want to receive for each such\nevent, navigating the data model\u2019s properties and relationships to\nconnect related data elements like pushes, repositories, and CI\nbuilds.\n\n\nTo use the above GraphQL subscription in an event handler, use the\n\nsubscriptionFromFile\n method:\n\n\n\n\nNote\n\n\nGraphClient.executeQueryFromFile\n and \nGraphQL.subscriptionFromFile\n\ntake an optional \ncurrent\n parameter. If omitted, Atomist tries to\nload GraphQL files from a \ngraphql\n directory in the root of your\nautomation client project.\n\n\nWhen specifying the filename, the \n.graphql\n extension is optional.\n\n\n\n\nMutations\n\u00b6\n\n\nMost of the data in the Atomist platform is ingested via Webhooks and\nis read-only.  There are however a small number of very useful GraphQL\nmutations available to handlers in automation clients.\n\n\n\n\n\n\n\n\nMutation\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncreateSlackChannel\n\n\nCreate a new public channel in Slack\n\n\n\n\n\n\naddBotToSlackChannel\n\n\nInvite the Atomist bot user into the given channel\n\n\n\n\n\n\ninviteUserToSlackChannel\n\n\nInvite any user into the given channel\n\n\n\n\n\n\nlinkSlackChannelToRepo\n\n\nLink a GitHub repository to a Slack channel\n\n\n\n\n\n\nsetTeamPreference\n\n\nSet preference data on the team entity\n\n\n\n\n\n\nsetUserPreference\n\n\nSet preference data on the user entity\n\n\n\n\n\n\n\n\nLike queries, mutations can be loaded from files and executed with the\n\nGraphClient\n. Here is an example showing how to create a new channel in Slack.\n\n\nHere\u2019s the GraphQL file containing the mutation:\n\n\nmutation CreateSlackChannel($name: String!) {\n  createSlackChannel(name: $name) {\n    id\n  }\n}\n\n\n\n\nThis invokes the mutation from the GraphQL file:\n\n\nctx\n.\ngraphClient\n.\nexecuteMutationFromFile\n(\n\"createSlackChannel\"\n,\n\n    \n{\n \nname\n:\n \n\"random\"\n},\n \n__dirname\n)\n\n    \n.\nthen\n(...)\n\n\n\n\n\nStrongly-typed GraphQL queries\n\u00b6\n\n\nOne nice side-effect of using GraphQL as the query layer is that you can generate\ntypes for use with TypeScript from the schema and your queries, subscriptions\nand mutations.\n\n\nTo generate types for your externalized GraphQL operations, run \nnpm run gql:gen\n.\nThis creates a file called \ntypes.ts\n in \nsrc/typings/\n.\n\n\nNow you can change the earlier query to use those types:\n\n\nimport\n \n*\n \nas\n \ngraphql\n \nfrom\n \n\"./typings/types\"\n;\n\n\n\npublic\n \nhandle\n(\nctx\n: \nHandlerContext\n)\n:\n \nPromise\n<\nHandlerResult\n>\n \n{\n\n\n    \nctx\n.\ngraphClient\n.\nexecuteQueryFromFile\n<\n\n        \ngraphql\n.\nPushesWithFailedBuilds\n.\nQuery\n,\n\n        \ngraphql\n.\nPushesWithFailedBuilds\n.\nVariables\n>\n(\n\n            \n\"pushesWithFailedBuilds\"\n,\n\n            \n{\n \nname\n:\n \n\"demo-service\"\n \n},\n\n            \n__dirname\n)\n\n        \n.\nthen\n(\nresult\n \n=>\n \n{\n\n            \n// Do something with the query result\n\n        \n},\n \nfailure\n);\n\n\n    \n// ....\n\n\n}\n\n\n\n\n\nThe event handler example from earlier can also now use types:\n\n\nimport\n \n*\n \nas\n \nGraphQL\n \nfrom\n \n\"@atomist/automation-client/graph/graphQL\"\n;\n\n\nimport\n \n*\n \nas\n \ngraphql\n \nfrom\n \n\"./typings/types\"\n;\n\n\n\n@EventHandler\n(\n\"Notify on broken builds\"\n,\n\n    \nGraphQL\n.\nsubscriptionFromFile\n(\n\"pushesWithFailedBuilds\"\n,\n \n__dirname\n))\n\n\nexport\n \nclass\n \nFailedBuildHandler\n\n    \nimplements\n \nHandleEvent\n<\ngraphql\n.\nPushesWithFailedBuilds\n.\nSubscription\n>\n \n{\n\n\n    \npublic\n \nhandle\n(\nevent\n: \nEventFired\n<\ngraphql\n.\nPushesWithFailedBuilds\n.\nSubscription\n>\n)\n \n{\n\n\n        \n// Now accessing properties is strongly typed\n\n        \nconst\n \nbuilds\n \n=\n \nevent\n.\ndata\n.\nPush\n[\n0\n].\nbuilds\n;\n\n\n        \n// ...\n\n    \n}\n\n\n}",
            "title": "Working with GraphQL"
        },
        {
            "location": "/developer/graphql/#accessing-data-with-graphiql",
            "text": "GraphiQL  is a GraphQL client\nthat helps you write queries and displays the shape of the resulting\ndata. It also provides access to the data model\u2019s documentation.   Note  On macOS it\u2019s easiest to install GraphiQL as a stand-alone app\nfrom  https://github.com/skevy/graphiql-app .   After installation you need to configure the endpoint and authentication in GraphiQL.  To setup authentication, click on  Edit HTTP Headers  and select  + Add Header .\nEnter  Authorization  as  Header name  and  Bearer <token>  as  Header value .\nReplace  <token>  with a GitHub personal access token that has  org:read  scope.   Note  Create and manage GitHub personal access tokens at: https://github.com/settings/tokens   Next, enter  https://automation.atomist.com/graphql/team/<teamId>  as  GraphQL\nEndpoint  replacing  <teamId>  with your Slack team ID. See the Setup section\non how to obtain your Slack team ID.  Now you are ready to create queries and explore the possibilities of the\nAtomist data model. Don\u2019t miss the schema documentation on the right hand side\nof GraphiQL.",
            "title": "Accessing data with GraphiQL"
        },
        {
            "location": "/developer/graphql/#queries",
            "text": "You can execute queries from command and event handlers when running an Atomist\nautomation client. To execute queries, the client provides two distinct methods\non  GraphClient . A  GraphClient  is available from the  HandlerContext .  You can use  executeQuery  to run a GraphQL query from a  string  instance.\nAlternatively, you can can use the  executeQueryFromFile  method to load and\nrun queries stored in  *.graphql  files.   Note  Externalizing queries makes it possible to generate types for use in\nyour TypeScript code. More on that later.   The following example shows you how to query for pushes and see all corresponding\ncontinuous integration builds.  Start by creating the query. The sample query includes a variable and a predicate that\nmatches only failed builds. This example assumes the query is saved in\na file called  pushesWithFailedBuilds.graphql .  query PushesWithFailedBuilds ($name: String!) {\n  Push {\n    repo(name: $name) {\n      name\n      owner\n    }\n    builds(status: failed) {\n      name\n      status\n      buildUrl\n    }\n  }\n}  Once the query is defined, you can use it with the  GraphClient  to execute\na query.  public   handle ( ctx :  HandlerContext ) :   Promise < HandlerResult >   { \n\n     ctx . graphClient . executeQueryFromFile ( \"pushesWithFailedBuilds\" , \n         {   name :   \"demo-service\"   },   __dirname ) \n         . then ( result   =>   { \n             // Do something with the query result \n         },   failure ); \n\n     // ....  }  \nThe  executeQueryFromFile  method takes the relative path to the external query\nfile as first parameter. The second parameter in the above example is the value for\nthe query variable. Lastly we specify  __dirname  to pass over the full path of\nthe current script which is needed to resolve the relative reference to the .graphql  file.",
            "title": "Queries"
        },
        {
            "location": "/developer/graphql/#subscriptions",
            "text": "As detailed in the section on event handlers, GraphQL subscriptions can be used\nto  subscribe  to events as they get ingested into the Atomist platform.  Subscriptions can\u2019t be executed with the  GraphClient ; instead they can only\nbe used from the  @EventHandler  decorator.  There are two ways to declare subscriptions on event handlers: either\nby embedded strings or by referencing external files, which is more reusable.  This example demonstrates subscribing using an external file:  subscription PushesWithFailedBuilds {\n  Push {\n    repo {\n      name\n      owner\n    }\n    builds(status: failed) {\n      name\n      status\n      buildUrl\n    }\n  }\n}  A GraphQL subscription begins with the keyword  subscription  followed\nby a name for the subscription,  PushesWithFailedBuilds  in this case.\nAfter the opening brace, you specify the type of the top-level event\nyou are subscribing to,  Push  in this example.  Your subscription\nthen defines the structured data you want to receive for each such\nevent, navigating the data model\u2019s properties and relationships to\nconnect related data elements like pushes, repositories, and CI\nbuilds.  To use the above GraphQL subscription in an event handler, use the subscriptionFromFile  method:   Note  GraphClient.executeQueryFromFile  and  GraphQL.subscriptionFromFile \ntake an optional  current  parameter. If omitted, Atomist tries to\nload GraphQL files from a  graphql  directory in the root of your\nautomation client project.  When specifying the filename, the  .graphql  extension is optional.",
            "title": "Subscriptions"
        },
        {
            "location": "/developer/graphql/#mutations",
            "text": "Most of the data in the Atomist platform is ingested via Webhooks and\nis read-only.  There are however a small number of very useful GraphQL\nmutations available to handlers in automation clients.     Mutation  Description      createSlackChannel  Create a new public channel in Slack    addBotToSlackChannel  Invite the Atomist bot user into the given channel    inviteUserToSlackChannel  Invite any user into the given channel    linkSlackChannelToRepo  Link a GitHub repository to a Slack channel    setTeamPreference  Set preference data on the team entity    setUserPreference  Set preference data on the user entity     Like queries, mutations can be loaded from files and executed with the GraphClient . Here is an example showing how to create a new channel in Slack.  Here\u2019s the GraphQL file containing the mutation:  mutation CreateSlackChannel($name: String!) {\n  createSlackChannel(name: $name) {\n    id\n  }\n}  This invokes the mutation from the GraphQL file:  ctx . graphClient . executeMutationFromFile ( \"createSlackChannel\" , \n     {   name :   \"random\" },   __dirname ) \n     . then (...)",
            "title": "Mutations"
        },
        {
            "location": "/developer/graphql/#strongly-typed-graphql-queries",
            "text": "One nice side-effect of using GraphQL as the query layer is that you can generate\ntypes for use with TypeScript from the schema and your queries, subscriptions\nand mutations.  To generate types for your externalized GraphQL operations, run  npm run gql:gen .\nThis creates a file called  types.ts  in  src/typings/ .  Now you can change the earlier query to use those types:  import   *   as   graphql   from   \"./typings/types\" ;  public   handle ( ctx :  HandlerContext ) :   Promise < HandlerResult >   { \n\n     ctx . graphClient . executeQueryFromFile < \n         graphql . PushesWithFailedBuilds . Query , \n         graphql . PushesWithFailedBuilds . Variables > ( \n             \"pushesWithFailedBuilds\" , \n             {   name :   \"demo-service\"   }, \n             __dirname ) \n         . then ( result   =>   { \n             // Do something with the query result \n         },   failure ); \n\n     // ....  }   The event handler example from earlier can also now use types:  import   *   as   GraphQL   from   \"@atomist/automation-client/graph/graphQL\" ;  import   *   as   graphql   from   \"./typings/types\" ;  @EventHandler ( \"Notify on broken builds\" , \n     GraphQL . subscriptionFromFile ( \"pushesWithFailedBuilds\" ,   __dirname ))  export   class   FailedBuildHandler \n     implements   HandleEvent < graphql . PushesWithFailedBuilds . Subscription >   { \n\n     public   handle ( event :  EventFired < graphql . PushesWithFailedBuilds . Subscription > )   { \n\n         // Now accessing properties is strongly typed \n         const   builds   =   event . data . Push [ 0 ]. builds ; \n\n         // ... \n     }  }",
            "title": "Strongly-typed GraphQL queries"
        },
        {
            "location": "/developer/create/",
            "text": "Create Projects\n\u00b6\n\n\nAutomated project creation saves time and ensures that you start new services, \nlibraries and other projects with good solid code that meets your standards\nand includes the components you need, configured the way you like them.\n\n\nIn Atomist, you automate project creation using a generator, a type of command. \nGenerators typically copy their code from a known-good repository called a seed,\nand then modify the code in certain ways, such as renaming classes so that it\u2019s\nready to use without lots of manual find and replace. Generators frequently also\nconfigure supporting systems, for example, by creating a dedicated\nSlack channel, setting up issue tracking, and so on.\n\n\nTo make your own generator, get an \nautomation client\n of your own.\nThen take a look at \na generator\n\n that makes a Spring 5 project \u2013 \nit \ndeclares a starting point\n and\n \ncustomizes that code\n.\n\n\nThe automation client hooks your generator up to Slack. You can also\nadd a custom form to serve project creation to your team or organization.\n\n\nA generator is one kind of \ncommand handler\n, so you can \nmake it do as much as you want.",
            "title": "Creating Projects"
        },
        {
            "location": "/developer/create/#create-projects",
            "text": "Automated project creation saves time and ensures that you start new services, \nlibraries and other projects with good solid code that meets your standards\nand includes the components you need, configured the way you like them.  In Atomist, you automate project creation using a generator, a type of command. \nGenerators typically copy their code from a known-good repository called a seed,\nand then modify the code in certain ways, such as renaming classes so that it\u2019s\nready to use without lots of manual find and replace. Generators frequently also\nconfigure supporting systems, for example, by creating a dedicated\nSlack channel, setting up issue tracking, and so on.  To make your own generator, get an  automation client  of your own.\nThen take a look at  a generator \n that makes a Spring 5 project \u2013 \nit  declares a starting point  and\n  customizes that code .  The automation client hooks your generator up to Slack. You can also\nadd a custom form to serve project creation to your team or organization.  A generator is one kind of  command handler , so you can \nmake it do as much as you want.",
            "title": "Create Projects"
        },
        {
            "location": "/developer/editors/",
            "text": "Atomist is about automating more of our own work, and that includes\nthe work of writing code.  Not all code, of course, but the repetitive\nparts of coding, or the code that you want to change across many\nprojects.  If the change would be so tedious to do by hand that you\nwouldn\u2019t even bother, consider automating it.\n\n\nAtomist provides tools that make automating writing code feasible.\nPowerful file and code parsing and editing primitives can easily be\nwrapped in \ncommand automations\n, allowing you and your team\nto apply your editors to one or all of your projects to update code\nand create pull requests.\n\n\nProject Editor\n\u00b6\n\n\nStart with a function that turns an existing Project into a promise of the Project you want it to be. We call this kind of function a \nProjectEditor\n.\n\n\ntype\n \nSimpleProjectEditor\n:\n  \n(\nproject\n: \nProject\n)\n \n=>\n \nPromise\n<\nProject\n>\n;\n\n\n\n\n\nThe Project is an abstraction over the filesystem. This is convenient because you can use an InMemoryProject for testing.\n\n\nThis \nexample\n adds a file with hard-coded content:\n\n\nimport\n \n{\n \nSimpleProjectEditor\n \n}\n \nfrom\n \n\"@atomist/automation-client/operations/edit/projectEditor\"\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/automation-client/project/Project\"\n;\n\n\n\nconst\n \naddMyFile\n: \nSimpleProjectEditor\n \n=\n \n(\nproject\n: \nProject\n,\n \nctx\n: \nHandlerContext\n)\n \n=>\n \n{\n\n    \nreturn\n \nproject\n.\naddFile\n(\n\"myFile.txt\"\n,\n \n\"I was here\"\n);\n\n\n}\n\n\n\n\n\nRunning an editor\n\u00b6\n\n\nAn editor can be transformed into a \ncommand\n automation; when invoked, the command will clone a repository, change the code, and push the results to GitHub as a pull request or commit.\n\n\nThis example will prompt for a repository, then create a pull request that adds the file.\n\n\nexport\n \nfunction\n \naddFileCommand\n()\n:\n \nHandleCommand\n \n{\n\n    \nreturn\n \neditorHandler\n(\n\n        \nparams\n \n=>\n \naddMyFile\n,\n\n        \nBaseEditorOrReviewerParameters\n,\n\n        \n\"AddMyFile\"\n,\n \n{\n\n            \ndescription\n:\n \n\"adds a tiny file\"\n,\n\n            \nintent\n:\n \n\"add my file\"\n,\n\n            \neditMode\n: \nnew\n \nPullRequest\n(\n\"one-tiny-file\"\n,\n \n\"Add a small file\"\n),\n\n        \n});\n\n\n}\n\n\n\n\n\nParameters\n\u00b6\n\n\nEditors all need to know which repository or repositories to work on. You can get additional parameters in the invocation as well, by creating your own Parameters class that extends BaseEditorOrReviewerParameters. The same ProjectEditor function works for both.\n\n\nSee the \nUpdateCopyright example\n for an example of each.\n\n\nPull requests or commits\n\u00b6\n\n\nThe \neditMode\n passed in the details to \neditorHandler\n determines how to save the changes. Pass an instance of \nPullRequest\n, or an implementation of \nBranchCommit\n. You can also supply a function from parameters to one of these EditModes, in case you want the branch name or commit message to vary by invocation.\n\n\nTesting a project editor\n\u00b6\n\n\nProjectEditor is a function, so it\u2019s testable. Unit testing at this level is quick and powerful.\n\n\nInMemoryProject\n\u00b6\n\n\nConstruct a project as input to your ProjectEditor. The simplest way is to list all the files and their content:\n\n\nimport\n \n{\n \nInMemoryProject\n \n}\n \nfrom\n \n\"@atomist/automation-client/project/mem/InMemoryProject\"\n;\n\n\n\nconst\n \nstartingProject\n \n=\n \nInMemoryProject\n.\nof\n({\n \npath\n:\n \n\"src/file1.ts\"\n,\n \n\"All the stuff in file1\"\n},\n\n                                           \n{\n \npath\n:\n \n\"test/file2.ts\"\n,\n \n\"All the stuff in file2\"\n});\n\n\n\n\n\nIf your editor uses the \nid\n property on the Project, populate that too, using \nInMemoryProject.from\n:\n\n\nimport\n \n{\n \nInMemoryProject\n \n}\n \nfrom\n \n\"@atomist/automation-client/project/mem/InMemoryProject\"\n;\n\n\n\nconst\n \nstartingProject\n \n=\n \nInMemoryProject\n.\nfrom\n({\n \nowner\n:\n \n\"atomist\"\n,\n \nrepo\n:\n \n\"end-user-documentation\"\n,\n \nsha\n:\n \n\"my-branch\"\n \n},\n\n                                             \n{\n \npath\n:\n \n\"src/file1.ts\"\n,\n \n\"All the stuff in file1\"\n},\n\n                                             \n{\n \npath\n:\n \n\"test/file2.ts\"\n,\n \n\"All the stuff in file2\"\n});\n\n\n\n\n\nHere is an \nexample\n of a mocha test for the addMyFile project editor:\n\n\nit\n(\n\"adds the file\"\n,\n \n(\ndone\n)\n \n=>\n \n{\n\n    \nconst\n \np\n \n=\n \nInMemoryProject\n.\nof\n({\n \npath\n:\n \n\"existingFile.txt\"\n,\n \ncontent\n:\n \n\"Hi\\n\"\n \n});\n\n    \naddMyFile\n(\np\n).\nthen\n(\nr\n \n=>\n \n{\n\n            \nassert\n(\np\n.\nfindFileSync\n(\n\"myFile.txt\"\n)\ngetContentSync\n().\nincludes\n(\n\"I was here\"\n);\n\n        \n}).\nthen\n(()\n \n=>\n \ndone\n(),\n \ndone\n);\n\n\n});\n\n\n\n\n\nWorking with projects\n\u00b6\n\n\nThe \nProject\n abstraction aims to provide both synchronous and asynchronous ways of changing projects. The synchronous methods simplify testing,\nwhile the asynchronous ones will give better performance in your automations.\n\n\nIf you want to modify the filesystem directly in your ProjectEditor function, do what you like; find the underlying directory in \nproject.baseDir\n.\n\n\nAccessing files\n\u00b6\n\n\nIf you know the path to the file you want to change, get to it with \nfindFile\n, and dig around in it with \ngetContents\n:\n\n\nimport\n \n{\n \nHandlerContext\n \n}\n \nfrom\n \n\"@atomist/automation-client\"\n;\n\n\nimport\n \n{\n \nSimpleProjectEditor\n \n}\n \nfrom\n \n\"@atomist/automation-client/operations/edit/projectEditor\"\n;\n\n\nimport\n \n{\n \nProject\n \n}\n \nfrom\n \n\"@atomist/automation-client/project/Project\"\n;\n\n\n\nexport\n \nconst\n \nchangeMyFile\n: \nSimpleProjectEditor\n \n=\n \n(\np\n: \nProject\n,\n \nctx\n: \nHandlerContext\n)\n \n=>\n\n        \np\n.\nfindFile\n(\n\"myFile.txt\"\n)\n\n            \n.\nthen\n(\nf\n \n=>\n \nf\n.\ngetContent\n()\n\n                \n.\nthen\n(\ncontent\n \n=>\n \nf\n.\nsetContent\n(\n\n                    \narbitraryManipulation\n(\ncontent\n))))\n\n            \n.\nthen\n(()\n \n=>\n \np\n);\n\n\n}\n\n\n\nfunction\n \narbitraryManipulation\n(\noldContent\n: \nstring\n)\n:\n \nstring\n \n{\n\n    \nreturn\n \noldContent\n \n+\n \n\" because I said so.\\n\"\n;\n\n\n}\n\n\n\n\n\nThere are many more methods on Project to help manipulate one or more files.\n\n\nChanging code\n\u00b6\n\n\nHow do we change code in code? There are the tools you\u2019re used to, and then the tools Atomist provides.\n\n\nSearch and replace\n\u00b6\n\n\nOften, a simple search and replace is enough. Perhaps you want to change a version of a dependency. If you know the file you want to change, and the change you want to make to it: find the file, and then use \nreplace\n. (It\u2019s the same as JavaScript\u2019s \nreplace\n.)\n\n\nThe following ProjectEditor finds package.json, finds a declaration about library-of-interest, and replaces the version with \n3.4.6\n.\n\n\nimport\n \nProject\n \nfrom\n \n...\n\n\nimport\n \nFile\n \nfrom\n \n...\n\n\n\nfunction\n \nupgradeLibrary\n(\nproject\n: \nProject\n)\n:\n \nPromise\n<\nProject\n>\n \n{\n\n    \nreturn\n \nproject\n.\nfindFile\n(\n\"package.json\"\n).\nthen\n((\nfile\n: \nFile\n)\n \n=>\n\n       \nfile\n.\nreplace\n(\n/\"library-of-interest\": \".*?\"/\n,\n\n                    \n`\"library-of-interest\": \"3.4.6\"`\n);\n\n    \n)\n\n\n}\n\n\n\n\n\n\n\nPlease import File from \u201c@atomist/automation-client/project/File\u201d, because TypeScript has a built-in File type that\u2019s different.\n\n\nNavigating language ASTs\n\u00b6\n\n\nYou can navigate the code in your Project based on your programming language\u2019s abstract syntax tree (AST). We include parsers for Java, Kotlin, and TypeScript; any language with an ANTLR grammar is supported.\n\n\nFor instance, \nthis editor\n discovers and manipulates constructors in Java code:\n\n\nconst\n \nConstructors\n \n=\n \n`//classBodyDeclaration[//constructorDeclaration]`\n;\n\n\n\nexport\n \nconst\n \nremoveAutowiredOnSoleConstructor\n: \nSimpleProjectEditor\n \n=\n \np\n \n=>\n \n{\n\n    \nreturn\n \nfindMatches\n(\np\n,\n \nJavaFileParser\n,\n \nJavaSourceFiles\n,\n \nConstructors\n)\n\n        \n.\nthen\n(\nconstructors\n \n=>\n \n{\n\n            \nif\n \n(\nconstructors\n.\nlength\n \n===\n \n1\n \n&&\n \nconstructors\n[\n0\n].\n$value\n.\nincludes\n(\n\"@Autowired\"\n))\n \n{\n\n                \nconstructors\n[\n0\n].\n$value\n \n=\n \nconstructors\n[\n0\n].\n$value\n.\nreplace\n(\n/@Autowired[\\s]+/\n,\n \n\"\"\n);\n\n            \n}\n\n            \nreturn\n \np\n.\nflush\n();\n\n        \n});\n\n\n};\n\n\n\n\n\nMore to come\n\u00b6\n\n\nThis page describes only some of the ProjectEditor functionality. There\u2019s additional information about project editors in \n@atomist/automation-client\n and its \nTypeDoc\n. Please come with further questions to \nSlack\n; we\u2019ll be happy to answer them.",
            "title": "Editing Projects"
        },
        {
            "location": "/developer/editors/#project-editor",
            "text": "Start with a function that turns an existing Project into a promise of the Project you want it to be. We call this kind of function a  ProjectEditor .  type   SimpleProjectEditor :    ( project :  Project )   =>   Promise < Project > ;   The Project is an abstraction over the filesystem. This is convenient because you can use an InMemoryProject for testing.  This  example  adds a file with hard-coded content:  import   {   SimpleProjectEditor   }   from   \"@atomist/automation-client/operations/edit/projectEditor\" ;  import   {   Project   }   from   \"@atomist/automation-client/project/Project\" ;  const   addMyFile :  SimpleProjectEditor   =   ( project :  Project ,   ctx :  HandlerContext )   =>   { \n     return   project . addFile ( \"myFile.txt\" ,   \"I was here\" );  }",
            "title": "Project Editor"
        },
        {
            "location": "/developer/editors/#running-an-editor",
            "text": "An editor can be transformed into a  command  automation; when invoked, the command will clone a repository, change the code, and push the results to GitHub as a pull request or commit.  This example will prompt for a repository, then create a pull request that adds the file.  export   function   addFileCommand () :   HandleCommand   { \n     return   editorHandler ( \n         params   =>   addMyFile , \n         BaseEditorOrReviewerParameters , \n         \"AddMyFile\" ,   { \n             description :   \"adds a tiny file\" , \n             intent :   \"add my file\" , \n             editMode :  new   PullRequest ( \"one-tiny-file\" ,   \"Add a small file\" ), \n         });  }",
            "title": "Running an editor"
        },
        {
            "location": "/developer/editors/#parameters",
            "text": "Editors all need to know which repository or repositories to work on. You can get additional parameters in the invocation as well, by creating your own Parameters class that extends BaseEditorOrReviewerParameters. The same ProjectEditor function works for both.  See the  UpdateCopyright example  for an example of each.",
            "title": "Parameters"
        },
        {
            "location": "/developer/editors/#pull-requests-or-commits",
            "text": "The  editMode  passed in the details to  editorHandler  determines how to save the changes. Pass an instance of  PullRequest , or an implementation of  BranchCommit . You can also supply a function from parameters to one of these EditModes, in case you want the branch name or commit message to vary by invocation.",
            "title": "Pull requests or commits"
        },
        {
            "location": "/developer/editors/#testing-a-project-editor",
            "text": "ProjectEditor is a function, so it\u2019s testable. Unit testing at this level is quick and powerful.",
            "title": "Testing a project editor"
        },
        {
            "location": "/developer/editors/#inmemoryproject",
            "text": "Construct a project as input to your ProjectEditor. The simplest way is to list all the files and their content:  import   {   InMemoryProject   }   from   \"@atomist/automation-client/project/mem/InMemoryProject\" ;  const   startingProject   =   InMemoryProject . of ({   path :   \"src/file1.ts\" ,   \"All the stuff in file1\" }, \n                                            {   path :   \"test/file2.ts\" ,   \"All the stuff in file2\" });   If your editor uses the  id  property on the Project, populate that too, using  InMemoryProject.from :  import   {   InMemoryProject   }   from   \"@atomist/automation-client/project/mem/InMemoryProject\" ;  const   startingProject   =   InMemoryProject . from ({   owner :   \"atomist\" ,   repo :   \"end-user-documentation\" ,   sha :   \"my-branch\"   }, \n                                              {   path :   \"src/file1.ts\" ,   \"All the stuff in file1\" }, \n                                              {   path :   \"test/file2.ts\" ,   \"All the stuff in file2\" });   Here is an  example  of a mocha test for the addMyFile project editor:  it ( \"adds the file\" ,   ( done )   =>   { \n     const   p   =   InMemoryProject . of ({   path :   \"existingFile.txt\" ,   content :   \"Hi\\n\"   }); \n     addMyFile ( p ). then ( r   =>   { \n             assert ( p . findFileSync ( \"myFile.txt\" ) getContentSync (). includes ( \"I was here\" ); \n         }). then (()   =>   done (),   done );  });",
            "title": "InMemoryProject"
        },
        {
            "location": "/developer/editors/#working-with-projects",
            "text": "The  Project  abstraction aims to provide both synchronous and asynchronous ways of changing projects. The synchronous methods simplify testing,\nwhile the asynchronous ones will give better performance in your automations.  If you want to modify the filesystem directly in your ProjectEditor function, do what you like; find the underlying directory in  project.baseDir .",
            "title": "Working with projects"
        },
        {
            "location": "/developer/editors/#accessing-files",
            "text": "If you know the path to the file you want to change, get to it with  findFile , and dig around in it with  getContents :  import   {   HandlerContext   }   from   \"@atomist/automation-client\" ;  import   {   SimpleProjectEditor   }   from   \"@atomist/automation-client/operations/edit/projectEditor\" ;  import   {   Project   }   from   \"@atomist/automation-client/project/Project\" ;  export   const   changeMyFile :  SimpleProjectEditor   =   ( p :  Project ,   ctx :  HandlerContext )   => \n         p . findFile ( \"myFile.txt\" ) \n             . then ( f   =>   f . getContent () \n                 . then ( content   =>   f . setContent ( \n                     arbitraryManipulation ( content )))) \n             . then (()   =>   p );  }  function   arbitraryManipulation ( oldContent :  string ) :   string   { \n     return   oldContent   +   \" because I said so.\\n\" ;  }   There are many more methods on Project to help manipulate one or more files.",
            "title": "Accessing files"
        },
        {
            "location": "/developer/editors/#changing-code",
            "text": "How do we change code in code? There are the tools you\u2019re used to, and then the tools Atomist provides.",
            "title": "Changing code"
        },
        {
            "location": "/developer/editors/#search-and-replace",
            "text": "Often, a simple search and replace is enough. Perhaps you want to change a version of a dependency. If you know the file you want to change, and the change you want to make to it: find the file, and then use  replace . (It\u2019s the same as JavaScript\u2019s  replace .)  The following ProjectEditor finds package.json, finds a declaration about library-of-interest, and replaces the version with  3.4.6 .  import   Project   from   ...  import   File   from   ...  function   upgradeLibrary ( project :  Project ) :   Promise < Project >   { \n     return   project . findFile ( \"package.json\" ). then (( file :  File )   => \n        file . replace ( /\"library-of-interest\": \".*?\"/ , \n                     `\"library-of-interest\": \"3.4.6\"` ); \n     )  }    Please import File from \u201c@atomist/automation-client/project/File\u201d, because TypeScript has a built-in File type that\u2019s different.",
            "title": "Search and replace"
        },
        {
            "location": "/developer/editors/#navigating-language-asts",
            "text": "You can navigate the code in your Project based on your programming language\u2019s abstract syntax tree (AST). We include parsers for Java, Kotlin, and TypeScript; any language with an ANTLR grammar is supported.  For instance,  this editor  discovers and manipulates constructors in Java code:  const   Constructors   =   `//classBodyDeclaration[//constructorDeclaration]` ;  export   const   removeAutowiredOnSoleConstructor :  SimpleProjectEditor   =   p   =>   { \n     return   findMatches ( p ,   JavaFileParser ,   JavaSourceFiles ,   Constructors ) \n         . then ( constructors   =>   { \n             if   ( constructors . length   ===   1   &&   constructors [ 0 ]. $value . includes ( \"@Autowired\" ))   { \n                 constructors [ 0 ]. $value   =   constructors [ 0 ]. $value . replace ( /@Autowired[\\s]+/ ,   \"\" ); \n             } \n             return   p . flush (); \n         });  };",
            "title": "Navigating language ASTs"
        },
        {
            "location": "/developer/editors/#more-to-come",
            "text": "This page describes only some of the ProjectEditor functionality. There\u2019s additional information about project editors in  @atomist/automation-client  and its  TypeDoc . Please come with further questions to  Slack ; we\u2019ll be happy to answer them.",
            "title": "More to come"
        },
        {
            "location": "/developer/client/",
            "text": "You interact with the Atomist development automation API via a\nclient \nWebSocket\n connection.  WebSocket connections are\npersistent, providing bidirectional communication between the client\nand the API.  As such, the client process is a persistent process with\na lifecycle that is more like a traditional \nserver\n process.  This\nsection documents creating, building, and running an automation\nclient, discusses each part of the client lifecycle, and details the\nstructure and organization of a typical automation client project.\n\n\nBefore you can build and run your own automation client,\nbe sure someone in your Slack team has completed\nthe \nsetup\n and you have satisfied\nthe \nprerequisites\n.  Specifically, be sure you have\n\n\n\n\nAdded the Atomist bot the your Slack team\n\n\nAuthorized Atomist to access GitHub\n\n\nInstalled Node.js\n\n\nInstalled the Atomist CLI\n\n\nRun \natomist config\n\n\n\n\nCreating a client project\n\u00b6\n\n\nAn automation client project is any project that connects to the\nAtomist development automation API.  The reference implementation of\nthe automation client is the \nautomation-client-ts\n\nlibrary, which is written in \nTypeScript\n.  The combination of\nTypeScript and \nGraphQL\n provides an excellent development\nexperience, with excellent tooling and debugging support.\n\n\nThere are a few ways to create a new automation client project.  We\nsuggest using the \nautomation-seed-ts\n project as a seed for\nyour automation client project.\n\n\nSlack\n\u00b6\n\n\nYou can create your very own automation client project using the\nAtomist bot.  You can run this bot command, which itself is\nimplemented as a command handler, with the following message to the\nAtomist bot:\n\n\n@atomist generate automation\n\n\n\n\nThe bot will ask you where you want to create it, what you want to\nname it, and, once creation is complete, tell you where you can find\nit.\n\n\nCommand line\n\u00b6\n\n\nYou can use the Atomist CLI to create a new automation project from\nthe automation-seed-ts project.  Run the following command, replacing\n\nPROJECT_NAME\n with the name of your new project.\n\n\natomist execute NewAutomation --name=PROJECT_NAME\n\n\n\n\nGitHub\n\u00b6\n\n\nIf you prefer the manual route, fixing up the project metadata\nyourself, you can always just fork the \nautomation-seed-ts\n\nproject on GitHub.\n\n\nBuilding a client\n\u00b6\n\n\nMost automation client projects are written in \nTypeScript\n and\nrun on \nNode.js\n.  Building an automation client is the same as\nany standard TypeScript or JavaScript project.  First you install the\nproject\u2019s dependencies\n\n\nnpm install\n\n\n\n\nthen build the project, linting the TypeScript, compiling the\nTypeScript into JavaScript, generating other required files, and\nrunning tests.\n\n\nnpm run build\n\n\n\n\nClient configuration\n\u00b6\n\n\nThe automation client will use the configuration you created when you\nran \natomist config\n as part of the \nprerequisites\n.  The\nconfiguration file, typically located under your home/user profile\ndirectory at \n.atomist/client.config.json\n.  It is a standard JSON\nfile that will look something like:\n\n\n{\n\n  \n\"token\"\n:\n \n\"abcdef0123456789abcdef0123456789abcdef01\"\n,\n\n  \n\"teamIds\"\n:\n \n[\n\n    \n\"TK421WAYA\"\n,\n\n  \n]\n\n\n}\n\n\n\n\n\nThe \ntoken\n is your \nGitHub personal access token\n and the\n\nteamIds\n are the Slack teams where you want to run your automations.\nIf you want to change the token or add/remove teams, you can just edit\nthis file directly.  Remember, whatever token you use, it must have at\nleast \nread:org\n and we recommend it also have the \nrepo\n scope.\n\n\nIf you are managing several automation client projects for different\nteams, you can override your user-level configuration using the\nproject-level configuration in each project, typically located at\n\nsrc/atomist.config.ts\n.  A typical project configuration file will\nlook like this:\n\n\nimport\n \n{\n \nConfiguration\n \n}\n \nfrom\n \n\"@atomist/automation-client/configuration\"\n;\n\n\nimport\n \n*\n \nas\n \nappRoot\n \nfrom\n \n\"app-root-path\"\n;\n\n\n\n// tslint:disable-next-line:no-var-requires\n\n\nconst\n \npj\n \n=\n \nrequire\n(\n`\n${\nappRoot\n}\n/package.json`\n);\n\n\n\nconst\n \ntoken\n \n=\n \nprocess\n.\nenv\n.\nGITHUB_TOKEN\n;\n\n\n\nexport\n \nconst\n \nconfiguration\n: \nConfiguration\n \n=\n \n{\n\n    \nname\n: \npj.name\n,\n\n    \nversion\n: \npj.version\n,\n\n    \nteamIds\n:\n \n[],\n\n    \ntoken\n,\n\n\n};\n\n\n\n\n\nIf the \nteamIds\n array exists and its length is greater than zero (0),\nthe value in the project configuration will be used.  If the\nenvironment variable \nGITHUB_TOKEN\n exists and has non-zero length, it\nwill be used.  For more complex configurations, e.g., different teams\nand tokens for different environments, you can use the \nconfig\n\nNode.js package to supply values for \nteamIds\n and \ntoken\n.\n\n\nBy default, all automations in your project will be registered with\nthe automation API when the client starts up (see \nlifecycle\n).  If\nyou only want a subset of your automations active, you can explicitly\nlist them using the \ncommands\n and \nevents\n arrays in the\n\nconfiguration\n object:\n\n\nimport\n \n{\n \nHelloWorld\n \n}\n \nfrom\n \n\"./commands/HelloWorld\"\n;\n\n\nimport\n \n{\n \nNotifyOnPush\n \n}\n \nfrom\n \n\"./events/NotifyOnPush\"\n;\n\n\n\nexport\n \nconst\n \nconfiguration\n: \nConfiguration\n \n=\n \n{\n\n    \nname\n: \npj.name\n,\n\n    \nversion\n: \npj.version\n,\n\n    \nteamIds\n:\n \n[],\n\n    \ntoken\n,\n\n    \ncommands\n:\n \n[\n\n        \nHelloWorld\n,\n\n    \n],\n\n    \nevents\n:\n \n[\n\n        \nNotifyOnPush\n,\n\n    \n],\n\n\n};\n\n\n\n\n\nStarting a client\n\u00b6\n\n\nThere are a few different ways to start the automation client,\ndepending on how you are running it.  If you are running the\nautomation client locally, you can use the standard NPM \nstart\n\ncommand.\n\n\nnpm start\n\n\n\n\nIf you are writing your own automations, you probably want a more\nresponsive testing environment, having the client restart any time you\nmake changes to the source code.  This fairly standard development\nflow is available with the \nautostart\n command.\n\n\nnpm run autostart\n\n\n\n\nWhen running in a production environment, you typically want to avoid\nNPM and run Node.js directly to ensure signals get delivered properly\nand you can provide guidance to Node.js\u2019s memory management subsystem.\nHere\u2019s an example startup command for production environments:\n\n\nnode $NODE_DEBUG_OPTION --trace-warnings --expose_gc --optimize_for_size \\\n    --always_compact --max_old_space_size=384 node_modules/.bin/atomist-client\n\n\n\n\nSee \nnode --help\n and \nnode --v8-options\n for more detail on these\noptions.\n\n\nClient lifecycle\n\u00b6\n\n\nThe automation client lifecycle will be familiar to those developing\npersistent applications.\n\n\n\n\n\n\nAuthentication\n - When the automation client starts up, it\n    connects to the automation API and authenticates using\n    the \nGitHub personal access token\n you have provided in\n    your client configuration file.  This token has \nread:org\n scope,\n    allowing the automation API to establish who you are and your\n    GitHub organization memberships.\n\n\n\n\n\n\nRegistration\n - Once your identity has been established, the\n    client registers its automations, i.e., the bot commands it\n    provides and the events it wants to receive, with the Slack teams\n    specified in your client configuration.  If Atomist does not\n    recognize your Slack team or your GitHub identity is not connected\n    to any member of that Slack team, registration will fail and the\n    client will exit with an unsuccessful status.\n\n\n\n\n\n\nListening\n - After authentication and registration is completed\n    successfully, the WebSocket connection is established and the\n    client begins listening for incoming messages from the API: bot\n    commands and events fired.\n\n\n\n\n\n\nShutdown\n - When the client receives a shutdown signal,\n    typically \nSIGINT\n delivered by the PaaS or \nCtrl-C\n, it\n    de-registers with the API and gracefully shuts down.\n\n\n\n\n\n\nProject structure\n\u00b6\n\n\nAutomation client projects are organized and behave like any standard\nTypeScript project.\n\n\npackage.json\n\u00b6\n\n\nThe \npackage.json\n file defines the metadata and dependencies for the\nproject.  In addition, this file defines the standard \u201cNPM package\nscripts\u201d, i.e., \nnpm run\n commands, typically available in Node.js\nprojects.  Here\u2019s a summary of the NPM package scripts available in\nmost automation client projects.\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnpm install\n\n\ninstall all the required packages\n\n\n\n\n\n\nnpm run autostart\n\n\nrun the client, refreshing when files change\n\n\n\n\n\n\nnpm run autotest\n\n\nrun tests every time files change\n\n\n\n\n\n\nnpm run build\n\n\nlint, compile, and test\n\n\n\n\n\n\nnpm run clean\n\n\nremove stray compiled JavaScript files and build directory\n\n\n\n\n\n\nnpm run compile\n\n\ncompile all TypeScript into JavaScript\n\n\n\n\n\n\nnpm run fmt\n\n\nrun tsfmt on TypeScript files\n\n\n\n\n\n\nnpm run lint\n\n\nrun tslint against the TypeScript\n\n\n\n\n\n\nnpm run lint:fix\n\n\nrun \ntslint --fix\n against the TypeScript\n\n\n\n\n\n\nnpm start\n\n\nstart the Atomist automation client\n\n\n\n\n\n\nnpm test\n\n\nrun tests\n\n\n\n\n\n\n\n\nbuild\n\u00b6\n\n\nThe \nbuild\n directory contains the JavaScript sources output from\nTypeScript compilation.\n\n\nconfig\n\u00b6\n\n\nThe \nconfig\n directory is optional, used only when you use\nthe \nconfig\n Node.js package.\n\n\ngraphql\n\u00b6\n\n\nThe \ngraphql\n directory contains \n.graphql\n files defining\nyour \nGraphQL\n queries, subscriptions, and mutations.  This\ndirectory is optional, as you can define your GraphQL in strings\nwithin the source code.  That said, it is recommended that you define\nyour GraphQL in \n.graphql\n files so you can realize the full benefit\nof its type bindings in TypeScript.\n\n\nnode_modules\n\u00b6\n\n\nThe \nnode_modules\n directory contains all the project dependencies, as\ndefined in the \npackage.json\n and installed by NPM.\n\n\nscripts\n\u00b6\n\n\nThe \nscripts\n directory contains various ancillary scripts.  For\nexample, this directory might have scripts for building the project on\nCI, publishing the project as an Node.js package, and publishing the\nproject\u2019s \nTypeDoc\n.\n\n\nsrc\n\u00b6\n\n\nThe \nsrc\n directory contains the TypeScript source code.\n\n\natomist.config.ts\n\u00b6\n\n\nThe \natomist.config.ts\n file contains automation client\nproject-specific configuration.\nSee \nClient Configuration\n for more details.\n\n\ncommands\n\u00b6\n\n\nThe \nsrc/commands\n directory contains the source code for commands.\n\n\nevents\n\u00b6\n\n\nThe \nsrc/events\n directory contains the source code for event\nhandlers.\n\n\ntypings\n\u00b6\n\n\nThe \nsrc/typings\n directory contains the auto-generated TypeScript\ntypes for your GraphQL queries, subscriptions, and mutations.\n\n\ntest\n\u00b6\n\n\nThe \ntest\n directory contains the automated tests for the project.\nTypically these are unit tests written using \nmocha\n\nand \npower-assert\n.",
            "title": "Automation Client"
        },
        {
            "location": "/developer/client/#creating-a-client-project",
            "text": "An automation client project is any project that connects to the\nAtomist development automation API.  The reference implementation of\nthe automation client is the  automation-client-ts \nlibrary, which is written in  TypeScript .  The combination of\nTypeScript and  GraphQL  provides an excellent development\nexperience, with excellent tooling and debugging support.  There are a few ways to create a new automation client project.  We\nsuggest using the  automation-seed-ts  project as a seed for\nyour automation client project.",
            "title": "Creating a client project"
        },
        {
            "location": "/developer/client/#slack",
            "text": "You can create your very own automation client project using the\nAtomist bot.  You can run this bot command, which itself is\nimplemented as a command handler, with the following message to the\nAtomist bot:  @atomist generate automation  The bot will ask you where you want to create it, what you want to\nname it, and, once creation is complete, tell you where you can find\nit.",
            "title": "Slack"
        },
        {
            "location": "/developer/client/#command-line",
            "text": "You can use the Atomist CLI to create a new automation project from\nthe automation-seed-ts project.  Run the following command, replacing PROJECT_NAME  with the name of your new project.  atomist execute NewAutomation --name=PROJECT_NAME",
            "title": "Command line"
        },
        {
            "location": "/developer/client/#github",
            "text": "If you prefer the manual route, fixing up the project metadata\nyourself, you can always just fork the  automation-seed-ts \nproject on GitHub.",
            "title": "GitHub"
        },
        {
            "location": "/developer/client/#building-a-client",
            "text": "Most automation client projects are written in  TypeScript  and\nrun on  Node.js .  Building an automation client is the same as\nany standard TypeScript or JavaScript project.  First you install the\nproject\u2019s dependencies  npm install  then build the project, linting the TypeScript, compiling the\nTypeScript into JavaScript, generating other required files, and\nrunning tests.  npm run build",
            "title": "Building a client"
        },
        {
            "location": "/developer/client/#client-configuration",
            "text": "The automation client will use the configuration you created when you\nran  atomist config  as part of the  prerequisites .  The\nconfiguration file, typically located under your home/user profile\ndirectory at  .atomist/client.config.json .  It is a standard JSON\nfile that will look something like:  { \n   \"token\" :   \"abcdef0123456789abcdef0123456789abcdef01\" , \n   \"teamIds\" :   [ \n     \"TK421WAYA\" , \n   ]  }   The  token  is your  GitHub personal access token  and the teamIds  are the Slack teams where you want to run your automations.\nIf you want to change the token or add/remove teams, you can just edit\nthis file directly.  Remember, whatever token you use, it must have at\nleast  read:org  and we recommend it also have the  repo  scope.  If you are managing several automation client projects for different\nteams, you can override your user-level configuration using the\nproject-level configuration in each project, typically located at src/atomist.config.ts .  A typical project configuration file will\nlook like this:  import   {   Configuration   }   from   \"@atomist/automation-client/configuration\" ;  import   *   as   appRoot   from   \"app-root-path\" ;  // tslint:disable-next-line:no-var-requires  const   pj   =   require ( ` ${ appRoot } /package.json` );  const   token   =   process . env . GITHUB_TOKEN ;  export   const   configuration :  Configuration   =   { \n     name :  pj.name , \n     version :  pj.version , \n     teamIds :   [], \n     token ,  };   If the  teamIds  array exists and its length is greater than zero (0),\nthe value in the project configuration will be used.  If the\nenvironment variable  GITHUB_TOKEN  exists and has non-zero length, it\nwill be used.  For more complex configurations, e.g., different teams\nand tokens for different environments, you can use the  config \nNode.js package to supply values for  teamIds  and  token .  By default, all automations in your project will be registered with\nthe automation API when the client starts up (see  lifecycle ).  If\nyou only want a subset of your automations active, you can explicitly\nlist them using the  commands  and  events  arrays in the configuration  object:  import   {   HelloWorld   }   from   \"./commands/HelloWorld\" ;  import   {   NotifyOnPush   }   from   \"./events/NotifyOnPush\" ;  export   const   configuration :  Configuration   =   { \n     name :  pj.name , \n     version :  pj.version , \n     teamIds :   [], \n     token , \n     commands :   [ \n         HelloWorld , \n     ], \n     events :   [ \n         NotifyOnPush , \n     ],  };",
            "title": "Client configuration"
        },
        {
            "location": "/developer/client/#starting-a-client",
            "text": "There are a few different ways to start the automation client,\ndepending on how you are running it.  If you are running the\nautomation client locally, you can use the standard NPM  start \ncommand.  npm start  If you are writing your own automations, you probably want a more\nresponsive testing environment, having the client restart any time you\nmake changes to the source code.  This fairly standard development\nflow is available with the  autostart  command.  npm run autostart  When running in a production environment, you typically want to avoid\nNPM and run Node.js directly to ensure signals get delivered properly\nand you can provide guidance to Node.js\u2019s memory management subsystem.\nHere\u2019s an example startup command for production environments:  node $NODE_DEBUG_OPTION --trace-warnings --expose_gc --optimize_for_size \\\n    --always_compact --max_old_space_size=384 node_modules/.bin/atomist-client  See  node --help  and  node --v8-options  for more detail on these\noptions.",
            "title": "Starting a client"
        },
        {
            "location": "/developer/client/#client-lifecycle",
            "text": "The automation client lifecycle will be familiar to those developing\npersistent applications.    Authentication  - When the automation client starts up, it\n    connects to the automation API and authenticates using\n    the  GitHub personal access token  you have provided in\n    your client configuration file.  This token has  read:org  scope,\n    allowing the automation API to establish who you are and your\n    GitHub organization memberships.    Registration  - Once your identity has been established, the\n    client registers its automations, i.e., the bot commands it\n    provides and the events it wants to receive, with the Slack teams\n    specified in your client configuration.  If Atomist does not\n    recognize your Slack team or your GitHub identity is not connected\n    to any member of that Slack team, registration will fail and the\n    client will exit with an unsuccessful status.    Listening  - After authentication and registration is completed\n    successfully, the WebSocket connection is established and the\n    client begins listening for incoming messages from the API: bot\n    commands and events fired.    Shutdown  - When the client receives a shutdown signal,\n    typically  SIGINT  delivered by the PaaS or  Ctrl-C , it\n    de-registers with the API and gracefully shuts down.",
            "title": "Client lifecycle"
        },
        {
            "location": "/developer/client/#project-structure",
            "text": "Automation client projects are organized and behave like any standard\nTypeScript project.",
            "title": "Project structure"
        },
        {
            "location": "/developer/client/#packagejson",
            "text": "The  package.json  file defines the metadata and dependencies for the\nproject.  In addition, this file defines the standard \u201cNPM package\nscripts\u201d, i.e.,  npm run  commands, typically available in Node.js\nprojects.  Here\u2019s a summary of the NPM package scripts available in\nmost automation client projects.     Command  Description      npm install  install all the required packages    npm run autostart  run the client, refreshing when files change    npm run autotest  run tests every time files change    npm run build  lint, compile, and test    npm run clean  remove stray compiled JavaScript files and build directory    npm run compile  compile all TypeScript into JavaScript    npm run fmt  run tsfmt on TypeScript files    npm run lint  run tslint against the TypeScript    npm run lint:fix  run  tslint --fix  against the TypeScript    npm start  start the Atomist automation client    npm test  run tests",
            "title": "package.json"
        },
        {
            "location": "/developer/client/#build",
            "text": "The  build  directory contains the JavaScript sources output from\nTypeScript compilation.",
            "title": "build"
        },
        {
            "location": "/developer/client/#config",
            "text": "The  config  directory is optional, used only when you use\nthe  config  Node.js package.",
            "title": "config"
        },
        {
            "location": "/developer/client/#graphql",
            "text": "The  graphql  directory contains  .graphql  files defining\nyour  GraphQL  queries, subscriptions, and mutations.  This\ndirectory is optional, as you can define your GraphQL in strings\nwithin the source code.  That said, it is recommended that you define\nyour GraphQL in  .graphql  files so you can realize the full benefit\nof its type bindings in TypeScript.",
            "title": "graphql"
        },
        {
            "location": "/developer/client/#node_modules",
            "text": "The  node_modules  directory contains all the project dependencies, as\ndefined in the  package.json  and installed by NPM.",
            "title": "node_modules"
        },
        {
            "location": "/developer/client/#scripts",
            "text": "The  scripts  directory contains various ancillary scripts.  For\nexample, this directory might have scripts for building the project on\nCI, publishing the project as an Node.js package, and publishing the\nproject\u2019s  TypeDoc .",
            "title": "scripts"
        },
        {
            "location": "/developer/client/#src",
            "text": "The  src  directory contains the TypeScript source code.",
            "title": "src"
        },
        {
            "location": "/developer/client/#atomistconfigts",
            "text": "The  atomist.config.ts  file contains automation client\nproject-specific configuration.\nSee  Client Configuration  for more details.",
            "title": "atomist.config.ts"
        },
        {
            "location": "/developer/client/#commands",
            "text": "The  src/commands  directory contains the source code for commands.",
            "title": "commands"
        },
        {
            "location": "/developer/client/#events",
            "text": "The  src/events  directory contains the source code for event\nhandlers.",
            "title": "events"
        },
        {
            "location": "/developer/client/#typings",
            "text": "The  src/typings  directory contains the auto-generated TypeScript\ntypes for your GraphQL queries, subscriptions, and mutations.",
            "title": "typings"
        },
        {
            "location": "/developer/client/#test",
            "text": "The  test  directory contains the automated tests for the project.\nTypically these are unit tests written using  mocha \nand  power-assert .",
            "title": "test"
        },
        {
            "location": "/developer/run/",
            "text": "Running Automation Clients\n\u00b6\n\n\nYou can run automation clients in many different environments, ranging from your laptop\nor data center to Platform-as-a-Service offerings like Heroku and Pivotal Cloud Foundry.\n\n\nAtomist also supports running clients as Docker containers. This allows you\nto operate them in Kubernetes clusters or Google Container Engine, for example.\n\n\nThis document explains various ways to run automation clients.\n\n\nRunning locally\n\u00b6\n\n\nThe easiest way to run an automation client is to start it up on your local\ndevelopment machine.\n\n\nRunning the automation client locally is extremely helpful\nduring development of your automations.\n\n\n\n\nYou can debug commands and event handlers using local development\n    tools like Visual Studio Code and Google Chrome.\n\n\nYou can iterate rapidly because there is no deployment and only a\n    minimal build process.\n\n\n\n\nIf you bootstrapped your client project using an Atomist seed and\ngenerator, start the client by running the following commands:\n\n\nnpm run compile && npm start\n\n\n\n\n\n\nNote\n\n\nThe automation client requires an open internet connection to\n\nhttps://automation.atomist.com\n to successfully and register event\nsubscriptions and commands.\n\n\n\n\nCloud Foundry\n\u00b6\n\n\nTo push your automation client to an instance of Pivotal Cloud\nFoundry, you need an account on the instance you want to target and\nyou must have the \nCloud Foundry CLI\n installed.\n\n\nFor detailed information about the deployment process, consult\nthe \nCloud Foundry documentation\n.\n\n\nA push to Cloud Foundry needs some additional metadata in your\nproject.  First you need to create a \nmanifest.yml\n\nfile in the root of your client:\n\n\napplications\n:\n\n\n-\n \nname\n:\n \nlifecycle-automation\n\n  \ncommand\n:\n \nnode node_modules/.bin/atomist-client\n\n  \nmemory\n:\n \n128M\n\n  \nroutes\n:\n\n  \n-\n \nroute\n:\n \nlifecycle.atomist.io\n\n  \nbuildpack\n:\n \nhttps://github.com/cloudfoundry/nodejs-buildpack\n\n  \nenv\n:\n\n    \nSUPPRESS_NO_CONFIG_WARNING\n:\n \ntrue\n\n    \nNODE_ENV\n:\n \nproduction\n\n\n\n\n\n\n\nNote\n\n\nTechnically a \nmanifest.yml\n is not required but it makes things\nsimpler.\n\n\n\n\nNext add an \n\"engines\"\n top-level entry to your \npackage.json\n\nfile:\n\n\n\"engines\"\n:\n \n{\n\n  \n\"node\"\n:\n \n\"8.x.x\"\n,\n\n  \n\"npm\"\n:\n \n\"5.x.x\"\n\n\n}\n\n\n\n\n\nFinally, start the deployment with:\n\n\ncf push\n\n\n\n\nDocker\n\u00b6\n\n\nShipping your automation client as a Docker image allows you to package\nup all required tools and dependencies. This is especially useful if you\nplan on reusing existing scripts or command line tools in your automations.\n\n\nTo set up a Docker image build, you need a \nDockerfile\n. Read the\ndocumentation on \nbuilding Docker images\n for more\ndetails.\n\n\nFROM\n node:8\n\n\n\n# Create application directory\n\n\nRUN\n mkdir -p /app\n\nWORKDIR\n /app\n\n\n\n# Install application dependencies\n\nCOPY package.json /app/\n\nRUN\n npm install\n\n\n# Bundle app source\n\nCOPY . /app\n\n\nENV\n SUPPRESS_NO_CONFIG_WARNING true\n\n\nENV\n NPM_CONFIG_LOGLEVEL warn\n\n\nENV\n NODE_ENV production\n\n\n\nEXPOSE\n 2866\n\n\n\nCMD\n [ \"npm\", \"start\" ]\n\n\n\n\n\nBe sure to create \n.dockerignore\n to exclude files\nand directories that aren\u2019t needed at runtime.\n\n\n/node_modules\n\n\n\n\nWith the \nDockerfile\n in place, you can now start the\nactual Docker build:\n\n\nnpm run compile && \\\n    docker build . -t lifecycle-automation:0.1.0\n\n\n\n\nAfter the build completes successfully, you can push the\nimage to any Docker image registry:\n\n\ndocker push lifecycle-automation:0.1.0",
            "title": "Running Automation Clients"
        },
        {
            "location": "/developer/run/#running-automation-clients",
            "text": "You can run automation clients in many different environments, ranging from your laptop\nor data center to Platform-as-a-Service offerings like Heroku and Pivotal Cloud Foundry.  Atomist also supports running clients as Docker containers. This allows you\nto operate them in Kubernetes clusters or Google Container Engine, for example.  This document explains various ways to run automation clients.",
            "title": "Running Automation Clients"
        },
        {
            "location": "/developer/run/#running-locally",
            "text": "The easiest way to run an automation client is to start it up on your local\ndevelopment machine.  Running the automation client locally is extremely helpful\nduring development of your automations.   You can debug commands and event handlers using local development\n    tools like Visual Studio Code and Google Chrome.  You can iterate rapidly because there is no deployment and only a\n    minimal build process.   If you bootstrapped your client project using an Atomist seed and\ngenerator, start the client by running the following commands:  npm run compile && npm start   Note  The automation client requires an open internet connection to https://automation.atomist.com  to successfully and register event\nsubscriptions and commands.",
            "title": "Running locally"
        },
        {
            "location": "/developer/run/#cloud-foundry",
            "text": "To push your automation client to an instance of Pivotal Cloud\nFoundry, you need an account on the instance you want to target and\nyou must have the  Cloud Foundry CLI  installed.  For detailed information about the deployment process, consult\nthe  Cloud Foundry documentation .  A push to Cloud Foundry needs some additional metadata in your\nproject.  First you need to create a  manifest.yml \nfile in the root of your client:  applications :  -   name :   lifecycle-automation \n   command :   node node_modules/.bin/atomist-client \n   memory :   128M \n   routes : \n   -   route :   lifecycle.atomist.io \n   buildpack :   https://github.com/cloudfoundry/nodejs-buildpack \n   env : \n     SUPPRESS_NO_CONFIG_WARNING :   true \n     NODE_ENV :   production    Note  Technically a  manifest.yml  is not required but it makes things\nsimpler.   Next add an  \"engines\"  top-level entry to your  package.json \nfile:  \"engines\" :   { \n   \"node\" :   \"8.x.x\" , \n   \"npm\" :   \"5.x.x\"  }   Finally, start the deployment with:  cf push",
            "title": "Cloud Foundry"
        },
        {
            "location": "/developer/run/#docker",
            "text": "Shipping your automation client as a Docker image allows you to package\nup all required tools and dependencies. This is especially useful if you\nplan on reusing existing scripts or command line tools in your automations.  To set up a Docker image build, you need a  Dockerfile . Read the\ndocumentation on  building Docker images  for more\ndetails.  FROM  node:8  # Create application directory  RUN  mkdir -p /app WORKDIR  /app  # Install application dependencies \nCOPY package.json /app/ RUN  npm install # Bundle app source \nCOPY . /app ENV  SUPPRESS_NO_CONFIG_WARNING true  ENV  NPM_CONFIG_LOGLEVEL warn  ENV  NODE_ENV production  EXPOSE  2866  CMD  [ \"npm\", \"start\" ]   Be sure to create  .dockerignore  to exclude files\nand directories that aren\u2019t needed at runtime.  /node_modules  With the  Dockerfile  in place, you can now start the\nactual Docker build:  npm run compile && \\\n    docker build . -t lifecycle-automation:0.1.0  After the build completes successfully, you can push the\nimage to any Docker image registry:  docker push lifecycle-automation:0.1.0",
            "title": "Docker"
        },
        {
            "location": "/support/",
            "text": "Thanks so much for choosing Atomist!  At Atomist, we want all\ndevelopers to excel.  We believe that given the right tools and\nguidance, all developers can be highly productive.  We strive to\nprovide tools that give their users super powers and we\u2019re happy to\nprovide any guidance we can to help you use them most effectively.  If\nyou have any questions or need any help of any kind, don\u2019t hesitate to\ncontact us in whatever way is most convenient for you.\n\n\n\n\nChat with us right here\n\n\nAtomist Community Slack\n\n\nsupport@atomist.com\n\n\nTwitter\n\n\nIssues and pull requests on our \nopen source projects\n\n\n\n\nWe exist to help you be as productive you can be.  Let us know how we\ncan help you.  Happy coding!",
            "title": "Support"
        }
    ]
}